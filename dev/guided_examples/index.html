<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Gravitational Example · FastMultipole.jl</title><meta name="title" content="Gravitational Example · FastMultipole.jl"/><meta property="og:title" content="Gravitational Example · FastMultipole.jl"/><meta property="twitter:title" content="Gravitational Example · FastMultipole.jl"/><meta name="description" content="Documentation for FastMultipole.jl."/><meta property="og:description" content="Documentation for FastMultipole.jl."/><meta property="twitter:description" content="Documentation for FastMultipole.jl."/><meta property="og:url" content="https://flow.byu.edu/FastMultipole.jl/guided_examples/"/><meta property="twitter:url" content="https://flow.byu.edu/FastMultipole.jl/guided_examples/"/><link rel="canonical" href="https://flow.byu.edu/FastMultipole.jl/guided_examples/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FastMultipole.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../quickstart/">Quick Start</a></li><li class="is-active"><a class="tocitem" href>Gravitational Example</a><ul class="internal"><li><a class="tocitem" href="#Overloading-body_to_multipole!"><span>Overloading <code>body_to_multipole!</code></span></a></li><li><a class="tocitem" href="#Buffer-Interface-Functions"><span>Buffer Interface Functions</span></a></li><li><a class="tocitem" href="#Overloading-direct!"><span>Overloading <code>direct!</code></span></a></li><li><a class="tocitem" href="#Running-the-FMM"><span>Running the FMM</span></a></li><li><a class="tocitem" href="#Preallocating-the-Buffers"><span>Preallocating the Buffers</span></a></li></ul></li><li><a class="tocitem" href="../vortex_filament/">Vortex Filament Example</a></li><li><a class="tocitem" href="../tuning/">Tuning Parameters</a></li><li><a class="tocitem" href="../advanced_usage/">Multiple Systems</a></li><li><a class="tocitem" href="../advanced_usage_2/">Automated Tuning</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Gravitational Example</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Gravitational Example</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/byuflowlab/FastMultipole.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/byuflowlab/FastMultipole.jl/blob/main/docs/src/guided_examples.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Gravitational-Example"><a class="docs-heading-anchor" href="#Gravitational-Example">Gravitational Example</a><a id="Gravitational-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Gravitational-Example" title="Permalink"></a></h1><p><code>FastMultipole</code> is designed to incorporate easily into your existing Julia code with minimal effort. In this section and the <a href="../vortex_filament/">Vortex Filament Example</a>, we demonstrate how this can be done.</p><p>First, we&#39;ll review the interface functions used by the gravitational point mass model used in <a href="../quickstart/#Quick-Start">Quick Start</a>. This code can also be found under <code>FastMultipole/test/gravitational.jl</code>.</p><p>To better understand how the <code>FastMultipole</code> interface functions, let&#39;s take a look at the data structures we&#39;ll use to define our point masses:</p><pre><code class="language-julia hljs">using FastMultipole
using FastMultipole.StaticArrays

const i_POTENTIAL = 1:1   # index of the gravitational potential
const i_GRADIENT = 5:7    # index of the gravitational acceleration
const i_HESSIAN = 8:16    # index of the hessian matrix

# a single point mass
struct Body{TF}
    position::SVector{3,TF}
    radius::TF
    strength::TF
end

# container for a system of `Body`&#39;s
struct Gravitational{TF}
    bodies::Vector{Body{TF}}
    potential::Matrix{TF}
end

# constructor
function Gravitational(bodies::Matrix)
    nbodies = size(bodies)[2]
    bodies2 = [Body(SVector{3}(bodies[1:3,i]),bodies[4,i],bodies[5,i]) for i in 1:nbodies]
    potential = zeros(eltype(bodies), 16, nbodies)
    return Gravitational(bodies2,potential)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.Gravitational</code></pre><p>In short, <code>Body</code> objects represent individual point masses, and the <code>Gravitational</code> object contains a group of them, along with a matrix of the potential, velocity, and velocity gradient at each body. The observant reader will notice that the <code>strength</code> field of <code>Body</code> represents its mass. </p><h2 id="Overloading-body_to_multipole!"><a class="docs-heading-anchor" href="#Overloading-body_to_multipole!">Overloading <code>body_to_multipole!</code></a><a id="Overloading-body_to_multipole!-1"></a><a class="docs-heading-anchor-permalink" href="#Overloading-body_to_multipole!" title="Permalink"></a></h2><p>The function <code>body_to_multipole!</code> is used to generate multipole expansions for our particular system. This is done be overloading <code>FastMultipole.body_to_multipole!</code> for our data structure. Convenience functions exist within <code>FastMultipole</code> to simplify this complicated function into a one-liner:</p><pre><code class="language-julia hljs">FastMultipole.body_to_multipole!(system::Gravitational, args...) =
    FastMultipole.body_to_multipole!(Point{Source}, system, args...)</code></pre><p>The <code>::Gravitational</code> type annotation is the key that allows <code>FastMultipole</code> to dispatch on <code>::Gravitational</code> systems. <code>Point{Source}</code> is used to indicate that our bodies are points and induce a source (i.e. <span>$1/r$</span>) potential. Other convenience functions exist in <code>FastMultipole</code> for any combination of <code>Point</code>, <code>Filament</code>, or <code>Panel</code> geometries using <code>Source</code>, <code>Dipole</code>, or <code>Vortex</code> kernels, and are specified when overloading <code>body_to_multipole!</code> as <code>&lt;geometry&gt;{&lt;kernel&gt;}</code>. For example, if my model used constant vortex sheet panels, I would replace <code>Point{Source}</code> in the example above to <code>Panel{Vortex}</code>.</p><div class="admonition is-success" id="Tip-bfd92747aeeb111"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-bfd92747aeeb111" title="Permalink"></a></header><div class="admonition-body"><p><code>FastMultipole</code> provides convenience functions for generating multipole coefficients for any combination of <code>Point</code>, <code>Filament</code>, or <code>Panel</code> geometries using <code>Source</code>, <code>Dipole</code>, or <code>Vortex</code> kernels. These are specified when overloading <code>body_to_multipole!</code> as <code>&lt;geometry&gt;{&lt;kernel&gt;}</code>.</p></div></div><p>We use the fast recursive method of generating exact coefficients for panels as developed by [<a href="../theory/#GUMEROV2023112118">1</a>]. We have derived our own formulae for vortex filaments and panels, which are in the process of publication.</p><p><code>FastMultipole</code> also requires the user to indicate if a source system induces a vector potential. This is done by overloading the <code>has_vector_potential</code> function as follows:</p><pre><code class="language-julia hljs">function FastMultipole.has_vector_potential(system::Gravitational)
    return false
end</code></pre><p>This will allow <code>FastMultipole</code> to avoid unnecessary calculations if the vector potential is not needed. Since <code>Gravitational</code> systems do not induce a vector potential, we return <code>false</code>.</p><h2 id="Buffer-Interface-Functions"><a class="docs-heading-anchor" href="#Buffer-Interface-Functions">Buffer Interface Functions</a><a id="Buffer-Interface-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Buffer-Interface-Functions" title="Permalink"></a></h2><p><code>FastMultipole</code> allocates a buffer matrix in which to sort and store key system information. The buffer interface is created by overloading several functions for the user-defined system type. The first of these functions is <a href="../reference/#FastMultipole.source_system_to_buffer!-NTuple{4, Any}"><code>FastMultipole.source_system_to_buffer!</code></a>, which populates a matrix with the important information about each body, column-wise. Overloading for <code>::Gravitational</code> systems looks like this:</p><pre><code class="language-julia hljs">function FastMultipole.source_system_to_buffer!(buffer, i_buffer, system::Gravitational, i_body)
    buffer[1:3, i_buffer] .= system.bodies[i_body].position
    buffer[4, i_buffer] = system.bodies[i_body].radius
    buffer[5, i_buffer] = system.bodies[i_body].strength
end</code></pre><p>Here, the <code>i_body</code>th body position, radius, and strength are copied to the correct positions in the <code>i_buffer</code>th column of the buffer matrix.</p><p>It is worth noting that there are ways of defining these functions that would harm performance, e.g. by allocating an array each time the velocity is requested. If you notice <code>FastMultipole</code>&#39;s performance is poor, this and the other interface functions are good places to check.</p><div class="admonition is-warning" id="Warning-8d3817b7e896aca9"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-8d3817b7e896aca9" title="Permalink"></a></header><div class="admonition-body"><p>The user-defined buffer interface functions are used frequently during an FMM call, so it is important to write them efficiently, avoiding allocations and following the Julia performance tips. If you notice that <code>FastMultipole</code>&#39;s performance is poor, this might be the reason.</p></div></div><p>Because every system can have a unique buffer structure, we need to overload a few additional functions to tell <code>FastMultipole</code> how to allocate and access it. The first function, <code>data_per_body</code>, returns the number of rows in the buffer matrix that are used to define a single body. The second function, <code>get_position</code>, returns the position of the <code>i</code>th body in the system. The third function, <code>strength_dims</code>, returns the number of rows in the buffer matrix that are used to define the strength of a single body. Finally, we overload <code>get_n_bodies</code> to return the number of bodies in our system. For our <code>Gravitational</code> system, we define:</p><pre><code class="language-julia hljs">Base.eltype(::Gravitational{TF}) where TF = TF

function FastMultipole.data_per_body(system::Gravitational)
    return 5
end

function FastMultipole.get_position(system::Gravitational, i)
    return system.bodies[i].position
end

function FastMultipole.strength_dims(system::Gravitational)
    return 1
end

FastMultipole.get_n_bodies(system::Gravitational) = length(system.bodies)</code></pre><p>These functions provide enough information for <code>FastMultipole</code> to allocate the buffer matrix and access the data it needs.</p><p>Finally, we need to tell <code>FastMultipole</code> how to transfer the results of the FMM call back to the user-defined system. This is done by overloading the <a href="../reference/#FastMultipole.buffer_to_target_system!-NTuple{5, Any}"><code>FastMultipole.buffer_to_target_system!</code></a> function. Overloading for <code>::Gravitational</code> systems looks like this:</p><pre><code class="language-julia hljs">function FastMultipole.buffer_to_target_system!(target_system::Gravitational, i_target, ::FastMultipole.DerivativesSwitch{PS,VS,GS}, target_buffer, i_buffer) where {PS,VS,GS}
    # get values
    TF = eltype(target_buffer)
    scalar_potential = PS ? FastMultipole.get_scalar_potential(target_buffer, i_buffer) : zero(TF)
    velocity = VS ? FastMultipole.get_gradient(target_buffer, i_buffer) : zero(SVector{3,TF})
    hessian = GS ? FastMultipole.get_hessian(target_buffer, i_buffer) : zero(SMatrix{3,3,TF,9})

    # update system
    target_system.potential[i_POTENTIAL[1], i_target] = scalar_potential
    target_system.potential[i_GRADIENT, i_target] .= velocity
    for (jj,j) in enumerate(i_HESSIAN)
        target_system.potential[j, i_target] = hessian[jj]
    end
end</code></pre><p>We note that the convenience functions <code>get_gradient</code> and <code>get_hessian</code> return <code>::SVector{3}</code> and <code>::SMatrix{3,3}</code>, respectively, to reduce allocations.</p><h2 id="Overloading-direct!"><a class="docs-heading-anchor" href="#Overloading-direct!">Overloading <code>direct!</code></a><a id="Overloading-direct!-1"></a><a class="docs-heading-anchor-permalink" href="#Overloading-direct!" title="Permalink"></a></h2><p>The last required interface function is <a href="../reference/#FastMultipole.direct!-NTuple{6, Any}"><code>FastMultipole.direct!</code></a>, which evaluates the potential at a target system using a source system without multipole acceleration. This is required in an FMM call for those interactions that are too close to be approximated by expansions. It is also useful for debugging and testing the accuracy of the FMM call. Overloading for <code>::Gravitational</code> systems, we have:</p><pre><code class="language-julia hljs">function FastMultipole.direct!(target_system, target_index, ::DerivativesSwitch{PS,VS,GS}, source_system::Gravitational, source_buffer, source_index) where {PS,VS,GS}
    @inbounds for i_source in source_index
        source_x, source_y, source_z = FastMultipole.get_position(source_buffer, i_source)
        source_strength = FastMultipole.get_strength(source_buffer, source_system, i_source)[1]
        @inbounds for j_target in target_index
            target_x, target_y, target_z = FastMultipole.get_position(target_system, j_target)
            dx = target_x - source_x
            dy = target_y - source_y
            dz = target_z - source_z
            r2 = dx*dx + dy*dy + dz*dz
            if r2 &gt; 0
                r = sqrt(r2)
                if PS
                    dϕ = source_strength / r * FastMultipole.ONE_OVER_4π
                    FastMultipole.set_scalar_potential!(target_system, j_target, dϕ)
                end
                if VS
                    dF = SVector{3}(dx,dy,dz) * source_strength / (r2 * r) * FastMultipole.ONE_OVER_4π
                    FastMultipole.set_gradient!(target_system, j_target, dF)
                end
            end
        end
    end
end</code></pre><p>Note that the velocity gradient is not calculated in this function. If the velocity gradient is requested, the contribution due to <code>::Gravitational</code> systems will then be zero.</p><div class="admonition is-success" id="Tip-5d2682b4feae26b3"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-5d2682b4feae26b3" title="Permalink"></a></header><div class="admonition-body"><p>Use the boolean type parameters of the <code>::DerivativesSwitch{PS,GS,HS}</code> argument when overloading the <code>direct!</code> to know when to compute the scalar potential, its gradient, and its hessian, respectively. This can save cost by avoiding unnecessary calculations.</p></div></div><h2 id="Running-the-FMM"><a class="docs-heading-anchor" href="#Running-the-FMM">Running the FMM</a><a id="Running-the-FMM-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-FMM" title="Permalink"></a></h2><p>Now that we have defined the interface functions, we can run the FMM on our <code>Gravitational</code> system to obtain the gravitational acceleration at each body. The <a href="../reference/#FastMultipole.fmm!"><code>fmm!</code></a> function is used to perform the FMM call as:</p><pre><code class="language-julia hljs">using Random

# create system
function generate_gravitational(seed, n_bodies; radius_factor=0.1, strength_scale=1/n_bodies, bodies_fun=(x)-&gt;x)
    # random seed
    Random.seed!(seed)

    # initialize bodies
    bodies = rand(5, n_bodies)

    # scale radius
    bodies[4,:] ./= (n_bodies^(1/3)*2)
    bodies[4,:] .*= radius_factor

    # scale strength
    bodies[5,:] .*= strength_scale

    # user-defined function for arbitrary transformation
    bodies_fun(bodies)

    # create system
    return Gravitational(bodies)
end

n_bodies, rand_seed = 5_000, 123
system = generate_gravitational(rand_seed, n_bodies)

# run FMM
fmm!(system; scalar_potential=false, gradient=true, hessian=true)

println(&quot;gravitational acceleration:\n&quot;, system.potential[5:7,1:10], &quot;...&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">gravitational acceleration:
[0.02952639011390768 -0.02069619176239785 0.025308790268953336 0.05962204518034472 0.0504774301877218 -0.035587328063329385 0.07821351262466984 -0.006666310179674633 0.026898010956689013 0.05271241254316844; 0.005306546782555571 -0.017169549499724216 -0.034257888440946294 0.014788007066020278 -0.01087048265953569 0.07495477398739561 0.04177523139954798 0.0745141881656066 0.08814587758750614 0.007071761637510552; 0.026157029327728353 0.07837748716099167 -0.07404854130606213 -0.024452264548083243 -0.042227331058716004 -0.02623074799497789 -0.01386135371171003 0.03345855691484015 -0.007767314674050915 -0.02552792181490425]...</code></pre><p>The <code>scalar_potential</code> and <code>gradient</code> arguments are set to <code>false</code> and <code>true</code>, respectively, to indicate that we want to compute the vector field (i.e. the gravitational field lines that translate to force and their gradient) but not the scalar potential.</p><div class="admonition is-warning" id="Warning-1aede2ebd8f87b6"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-1aede2ebd8f87b6" title="Permalink"></a></header><div class="admonition-body"><p>The user must specify which fields they want to be computed by the FMM by setting the boolean keyword arguments <code>scalar_potential</code>, <code>gradient</code>, and <code>hessian</code> when calling <code>fmm!</code> (defaults are <code>scalar_potential=false</code>, <code>gradient=true</code>, and <code>hessian=false</code>). Note also that if the source system induces a vector potential (as indicated by the interface function <code>has_vector_potential(system)=true</code>), then the <code>scalar_potential</code> keyword should be set to <code>false</code>, since the scalar potential will be non-sensical in this case.</p></div></div><h2 id="Preallocating-the-Buffers"><a class="docs-heading-anchor" href="#Preallocating-the-Buffers">Preallocating the Buffers</a><a id="Preallocating-the-Buffers-1"></a><a class="docs-heading-anchor-permalink" href="#Preallocating-the-Buffers" title="Permalink"></a></h2><p>The <code>fmm!</code> function incurs a small overhead for allocating the buffer matrices. If our system is large and the FMM will be called more than once, we can preallocate the buffers to avoid this overhead. This is done by returning a <code>cache</code> of preallocated memory the first time <code>fmm!</code> is called, and then adding it as an additional argument to <code>fmm!</code> in subsequent calls as follows:</p><pre><code class="language-julia hljs"># allocate buffer cache
allocs_1 = @allocated _, cache, _ = fmm!(system; scalar_potential=false, gradient=true, hessian=true)

# run FMM with preallocated buffers
allocs_2 = @allocated fmm!(system, cache; scalar_potential=false, gradient=true, hessian=true)

println(&quot;memory allocated without the cache:  &quot;, allocs_1, &quot; bytes&quot;)
println(&quot;memory allocated with the cache:     &quot;, allocs_2, &quot; bytes&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">memory allocated without the cache:  8407560 bytes
memory allocated with the cache:     7257304 bytes</code></pre><p>Note that the second call to <code>fmm!</code> allocates less memory.</p><div class="admonition is-success" id="Tip-f8c34e5b55c3213e"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-f8c34e5b55c3213e" title="Permalink"></a></header><div class="admonition-body"><p>If you plan to call <code>fmm!</code> multiple times on the same system, consider preallocating the buffers by saving the <code>cache</code> returned by the first call, and splatting it as a keyword argument for each subsequent call. This can reduce memory allocations and improve performance.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quickstart/">« Quick Start</a><a class="docs-footer-nextpage" href="../vortex_filament/">Vortex Filament Example »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Wednesday 18 June 2025 22:48">Wednesday 18 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
