var documenterSearchIndex = {"docs":
[{"location":"advanced_usage/#Advanced-Usage","page":"Advanced Usage","title":"Advanced Usage","text":"","category":"section"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"Though the typical user won't need to alter these parameters, various situations may require modifications to the evaluation process of the FMM.","category":"page"},{"location":"advanced_usage/#Unsort-Bodies","page":"Advanced Usage","title":"Unsort Bodies","text":"","category":"section"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"As part of the evaluation, the fmm! call will sort bodies contained in the systems in order to optimize performance, thus during the fmm evaluation, the body indices are different from initial indices given by the user. At the conclusion of the fmm! call, these bodies are then put back in their original order for the convenience of the user. This feature can be toggled off so that the bodies are left in their sorted order after the FMM evaluation.","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"import FastMultipole as fmm\nusing Random\ngravitational_path = normpath(joinpath(splitdir(pathof(fmm))[1], \"..\", \"test\", \"gravitational.jl\"))\ninclude(gravitational_path)\n\nfunction generate_gravitational(seed, n_bodies; radius_factor=0.1, strength_factor=1.0)\n    Random.seed!(seed)\n    bodies = rand(8,n_bodies)\n    bodies[1:3,:] = rand(3,n_bodies) # body positions\n\n    bodies[4,:] ./= (n_bodies^(1/3)*2) # body radii\n    bodies[4,:] .*= radius_factor\n\n    bodies[5,:] .*= strength_factor # body strengths\n\n    system = Gravitational(bodies)\n    return system\nend\n\ntarget_system = generate_gravitational(123, 100)\nsource_system = generate_gravitational(321, 100)\n\nfmm.fmm!(target_system, source_system,\n    unsort_source_bodies=true, unsort_target_bodies=true) # standard run (defaults)\nfmm.fmm!(target_system, source_system,\n    unsort_source_bodies=false, unsort_target_bodies=false) # sorted bodies (not original indices)","category":"page"},{"location":"advanced_usage/#Reusing-the-Octree","page":"Advanced Usage","title":"Reusing the Octree","text":"","category":"section"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"Users are able to define the tree to be used in the FMM by passing in a previously created tree into the fmm! call. For convenience, the upward_pass, horizontal_pass, and downward_pass can be toggled off seperately. These are important to toggle when generating octrees to be reused. Additionally, unsort_target_bodies and unsort_source_bodies should be set to false when generating the reusable trees.","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"upward_pass creates the multipole expansions for each branch\nhorizontal_pass evaluates the expansions in the appropriate locations\ndownward_pass applies parent expansions to children branches","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"target_system = generate_gravitational(123, 100)\nsource_system = generate_gravitational(321, 100)\n\ntarget_tree, source_tree = fmm.fmm!(target_system, source_system;\n    upward_pass=true, horizontal_pass=false, downward_pass=false,\n    unsort_source_bodies=false, unsort_target_bodies=false) # generating trees to be reused\n\nfmm.fmm!(target_tree, target_system, source_tree, source_system;\n    upward_pass=false, horizontal_pass=true, downward_pass=true) # reusing trees","category":"page"},{"location":"advanced_usage/#Partial-Evaluation","page":"Advanced Usage","title":"Partial Evaluation","text":"","category":"section"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"The nearfield, farfield, and self_induced parameters allow users to bypass certain portions of the FMM.","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"nearfield if false, FastMultipole omits all direct interactions\nfarfield if false, FastMultipole omits all multipole interactions\nself_induced if false, FastMultipole omits the interaction of each leaf branch on itself","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"system = generate_gravitational(123, 100)\nfmm.fmm!(system,\n    nearfield=true, farfield=true, self_induced=true) # standard run (defaults)\nfmm.fmm!(system,\n    nearfield=false, farfield=true, self_induced=true) # nearfield not evaluated","category":"page"},{"location":"advanced_usage/#Resize-and-Recenter-Branches","page":"Advanced Usage","title":"Resize and Recenter Branches","text":"","category":"section"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"The initial creation of the octree will create uniformly sized and spaced branches in each level. These branches are not centered or optimally sized with relation to the bodies they contain. As a default, the fmm! call resizes and recenters these branches to utilize the smallest possible radius that contains all the bodies in each branch[3]. This feature can be toggled with the source_shrink_recenter and target_shrink_recenter parameters.","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"target_system = generate_gravitational(123, 100)\nsource_system = generate_gravitational(321, 100)\n\nfmm.fmm!(target_system, source_system,\n    source_shrink_recenter=true, target_shrink_recenter=true) # standard run (defaults)\nfmm.fmm!(target_system, source_system,\n    source_shrink_recenter=false, target_shrink_recenter=false) # no branch recentering","category":"page"},{"location":"guided_examples/#Guided-Examples","page":"Guided Examples","title":"Guided Examples","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"FastMultipole is designed to incorporate easily into your existing Julia code with minimal effort. We'll walk through the process of adding FastMultipole to an existing code in the following guided examples.","category":"page"},{"location":"guided_examples/#Gravitational-Example","page":"Guided Examples","title":"Gravitational Example","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"In order to use FastMultipole, certain interface functions must be defined. In this example, we will walk through the process of incorporating FMM into the gravitational point mass model used in Quick Start. This code can also be found under test/gravitational.jl. Note that an additional (minimalistic) vortex particle example is included in test/vortex.jl.","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"To better understand how the FastMultipole interface functions, let's take a look at the data structures we'll use to define our point masses:","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"using FastMultipole\nusing FastMultipole.StaticArrays\n\nconst i_POTENTIAL = 1:4             # index of the gravitational potential\nconst i_VELOCITY = 5:7              # index of the velocity\nconst i_VELOCITY_GRADIENT = 8:16    # index of the velocity gradient\n\n# a single point mass\nstruct Body{TF}\n    position::SVector{3,TF}\n    radius::TF\n    strength::SVector{4,TF}\nend\n\n# container for a system of `Body`'s\nstruct Gravitational{TF}\n    bodies::Vector{Body{TF}}\n    potential::Matrix{TF}\nend\n\n# constructor\nfunction Gravitational(bodies::Matrix)\n    nbodies = size(bodies)[2]\n    bodies2 = [Body(SVector{3}(bodies[1:3,i]),bodies[4,i],SVector{4}(bodies[5:8,i])) for i in 1:nbodies]\n    potential = zeros(52,nbodies)\n    return Gravitational(bodies2,potential)\nend","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"Note that while the particular choice of data structures is completely arbitrary, FastMultipole does not create any new storage containers for values of interest such as potential, velocity, velocity gradient. If these are desired, they must exist in the user-defined system, and will be updated in-place by FastMultipole.","category":"page"},{"location":"guided_examples/#Overloading-the-body_to_multipole!-Function","page":"Guided Examples","title":"Overloading the body_to_multipole! Function","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"The function body_to_multipole! is used to generate multipole expansions for our particular system. This is done be overloading body_to_multipole! for the data structure representing our model. Convenience functions exist within FastMultipole to make this complicated function into a one-liner:","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"FastMultipole.body_to_multipole!(system::Gravitational, args...) =\n    FastMultipole.body_to_multipole!(Point{Source}, system, args...)","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"Note that we are overloading body_to_multipole! to operate on our ::Gravitational system, which consists of point sources. Other convenience functions exist in FastMultipole for any combination of Point, Filament, or Panel geometries using Source, Dipole, or Vortex kernels. These are specified when overloading body_to_multipole! as <geometry>{<kernel>}. For example, if my model used vortex filaments, I would replace Point{Source} in the example above to Filament{Vortex}.","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"We use the fast recursive method of generating exact coefficients for panels as developed by [1].","category":"page"},{"location":"guided_examples/#Overloading-Getters","page":"Guided Examples","title":"Overloading Getters","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"The Gravitational struct needs the following getters to be overloaded to support the indexing format used by FastMultipole. This approach allows for great flexibility without harming performance.","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"import Base: getindex\n\nBase.getindex(g::Gravitational, i, ::FastMultipole.Position) = g.bodies[i].position\nBase.getindex(g::Gravitational, i, ::FastMultipole.Radius) = g.bodies[i].radius\nBase.getindex(g::Gravitational, i, ::FastMultipole.ScalarPotential) = g.potential[1,i]\nBase.getindex(g::Gravitational, i, ::FastMultipole.Velocity) = view(g.potential,i_VELOCITY,i)\nBase.getindex(g::Gravitational, i, ::FastMultipole.VelocityGradient) = reshape(view(g.potential,i_VELOCITY_GRADIENT,i),3,3)\nBase.getindex(g::Gravitational, i, ::FastMultipole.Strength) = g.bodies[i].strength[1]\nBase.getindex(g::Gravitational, i, ::FastMultipole.Body) = g.bodies[i], view(g.potential,:,i)","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"It is worth noting that there are ways of defining these functions that would harm performance, e.g. by allocating an array each time the velocity is requested. It is up to the user to define these functions with the efficiency they desire.","category":"page"},{"location":"guided_examples/#Overloading-Setters","page":"Guided Examples","title":"Overloading Setters","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"Gravitational also needs the following setters to be overloaded as well. These are used to update the potential and other quantities in-place. The same performance considerations that applied to getters apply here.","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"import Base: setindex!\n\nfunction Base.setindex!(g::Gravitational, val, i, ::FastMultipole.Body)\n    body, potential = val\n    g.bodies[i] = body\n    g.potential[:,i] .= potential\n    return nothing\nend\nfunction Base.setindex!(g::Gravitational, val, i, ::FastMultipole.ScalarPotential)\n    g.potential[i_POTENTIAL[1],i] = val\nend\nfunction Base.setindex!(g::Gravitational, val, i, ::FastMultipole.Velocity)\n    g.potential[i_VELOCITY,i] .= val\nend\nfunction Base.setindex!(g::Gravitational, val, i, ::FastMultipole.VelocityGradient)\n    reshape(g.potential[i_VELOCITY_GRADIENT,i],3,3) .= val\nend","category":"page"},{"location":"guided_examples/#Additional-Requirements","page":"Guided Examples","title":"Additional Requirements","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"In addition to the getters and setters listed above, each system struct must be overloaded with three additional methods. In gravitational.jl, these are they are overloaded as follows.","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"# determine the number of bodies contained by the system\nFastMultipole.get_n_bodies(g::Gravitational) = length(g.bodies)\n\n# determine the float-type used by the system\nBase.eltype(::Gravitational{TF}) where TF = TF\n\n# return all data structures required to define a single body\nFastMultipole.buffer_element(g::Gravitational) = (deepcopy(g.bodies[1]),zeros(eltype(g),52))","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"Note that the last of these functions, buffer_element, can return a tuple of values in case multiple data structures are required to define a single body.","category":"page"},{"location":"guided_examples/#Vector-Potential","page":"Guided Examples","title":"Vector Potential","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"Ordinarily, a 3-dimensional vector potential, such as the stream function in 3-dimensional fluid dynamics, requires 3 separate expansions (1 for each dimension). In FastMultipole, however, we employ the Lamb-Helmholtz decomposition demonstrated by [2] to reduce the number of expansions required from 3 to 2, thus reducing computational cost.","category":"page"},{"location":"guided_examples/#Non-required-Functionality","page":"Guided Examples","title":"Non-required Functionality","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"Though not required to run Fast Multipole, the direct! and save_vtk functions are useful for debugging and visualization. Here are some examples of how this could be implemented.","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"function FastMultipole.direct!(target_system, target_index, derivatives_switch, source_system::Gravitational, source_index)\n    # nbad = 0\n    for i_source in source_index\n        source_x, source_y, source_z = source_system[i_source,FastMultipole.POSITION]\n        source_strength = source_system.bodies[i_source].strength[1]\n        for j_target in target_index\n            target_x, target_y, target_z = target_system[j_target,FastMultipole.POSITION]\n            dx = target_x - source_x\n            dy = target_y - source_y\n            dz = target_z - source_z\n            r = sqrt(dx*dx + dy*dy + dz*dz)\n            # te = @elapsed begin\n            if r > 0\n                dV = source_strength / r\n                target_system[j_target,FastMultipole.SCALAR_POTENTIAL] += dV\n            end\n        # end\n        # if te > 0.00001; nbad += 1; end\n        end\n    end\n    # println(\"nbad = $nbad\")\nend\n\nfunction save_vtk(filename, element::Gravitational, nt=0; compress=false, extra_fields=nothing)\n    _, n = size(element.bodies)\n    WriteVTK.vtk_grid(filename*\"_point_masses.\"*string(nt)*\".vts\", reshape(view(element.bodies,1:3,:),3,n,1,1); compress) do vtk\n        vtk[\"strength\"] = reshape(view(element.bodies,4,:), 1, n, 1, 1)\n        vtk[\"velocity\"] = reshape(element.velocity, 3, n, 1, 1)\n        vtk[\"scalar potential\"] = reshape(view(element.potential,1,:), n, 1, 1)\n        vtk[\"vector potential\"] = reshape(view(element.potential,2:4,:), 3, n, 1, 1)\n        if !isnothing(extra_fields)\n            for i in 1:length(extra_fields)\n                vtk[extra_fields[i][1]] = extra_fields[i][2]\n            end\n        end\n    end\nend\n","category":"page"},{"location":"guided_examples/#FMM-Tuning-Parameters","page":"Guided Examples","title":"FMM Tuning Parameters","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"We can improve the accuracy of the FMM by altering the follwing input parameters: multipole_threshold, leaf_size, and expansion_order. Though not linear, expansion_order is positively correlated with accuracy while multipole_threshold and leaf_size are negatively correlated.","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"multipole_threshold (between 0 and 1) the radius of the source over the minimum distance at which multipole expansion are used\nleaf_size (greater than 1) the maximum number of bodies included in each leaf level branch\nexpansion_order the number of terms included in each multipole expansion minus one","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"import FastMultipole as fmm\nusing Random\n\nfunction generate_gravitational(seed, n_bodies; radius_factor=0.1, strength_factor=1.0)\n    Random.seed!(seed)\n    bodies = rand(8,n_bodies)\n    bodies[1:3,:] = rand(3,n_bodies) # body positions\n\n    bodies[4,:] ./= (n_bodies^(1/3)*2) # body radii\n    bodies[4,:] .*= radius_factor\n\n    bodies[5,:] .*= strength_factor # body strengths\n\n    system = Gravitational(bodies)\n    return system\nend\n\nfunction measure_error(;multipole_threshold=0.4, leaf_size=50, expansion_order=5)\n    fmm_system = generate_gravitational(123,1000)\n    direct_system = deepcopy(fmm_system)\n\n    fmm.fmm!(fmm_system; multipole_threshold, leaf_size, expansion_order)\n    fmm.direct!(direct_system)\n\n    percent_error = abs.((fmm_system.potential[1,:] .- direct_system.potential[1,:]) ./ direct_system.potential[1,:])\n    return maximum(percent_error)\nend\n\n# default parameters\nprintln(measure_error(multipole_threshold=0.4, leaf_size=50, expansion_order=5))\n\n# expansion_order increased to 10\nprintln(measure_error(multipole_threshold=0.4, leaf_size=50, expansion_order=10))","category":"page"},{"location":"guided_examples/#Evaluate-Source-on-Target","page":"Guided Examples","title":"Evaluate Source on Target","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"FastMutipole allows for the evaluation of source systems on target systems while leaving the source systems unaltered.","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"target_system = generate_gravitational(123, 100)\nsource_system = generate_gravitational(321, 100)\n\nfmm.fmm!(target_system, source_system)","category":"page"},{"location":"guided_examples/#Evaluate-Multiple-Sources-on-Multiple-Targets","page":"Guided Examples","title":"Evaluate Multiple Sources on Multiple Targets","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"The FMM also supports the evaluation of multiple source systems on multiple target systems. The user is also able to evaluate a single source on multiple targets or multiple sources on a single target with any combination of supported system types.","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"vortex_path = normpath(joinpath(splitdir(pathof(fmm))[1], \"..\", \"test\", \"vortex.jl\"))\ninclude(vortex_path)\n\nfunction generate_vortex(seed, n_bodies; radius_factor=0.1, strength_factor=1.0)\n    Random.seed!(seed)\n    bodies = rand(8,n_bodies)\n    bodies[1:3,:] = rand(3,n_bodies) # body positions\n\n    bodies[4,:] ./= (n_bodies^(1/3)*2) # body radii\n    bodies[4,:] .*= radius_factor\n\n    bodies[5,:] .*= strength_factor # body strengths\n\n    system = VortexParticles(bodies)\n    return system\nend\n\ntarget_one = generate_gravitational(123, 100)\ntarget_two = generate_vortex(124, 100)\n\nsource_one = generate_gravitational(125, 100)\nsource_two = generate_vortex(126, 100)\n\nfmm.fmm!((target_one, target_two), (source_one, source_two))","category":"page"},{"location":"guided_examples/#Non-Potential-Flow-Applications","page":"Guided Examples","title":"Non-Potential Flow Applications","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"As a default, target systems will be evaluated and returned with scalar_potential, velocity, and velocity_gradient fields populated. (Note that the vector potential is not explicitly tracked, though its induced velocity and velocity gradient are.) In some situations, only some of these values may be required. By inputting a boolean vector of the same length as target systems, the user is able to speed up the calculation by not storing unecessary values.","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"overlineV = -nabla phi + nabla times overlinepsi","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":" phi overlinepsi overlineV nabla overlineV\nfmm! Keyword Arguments scalar_potential vector_potential velocity velocity_gradient\nFluid Dynamics Scalar Potential Stream Function Fluid Velocity Velocity Gradient\nElectrostatics Electric Potential - Electric Field Field Gradient Tensor\nMagnetostatics - Magnetic Vector Potential Magnetic Field Field Gradient Tensor\nGravity Gravitational Potential - Gravitational Acceleration Acceleration Gradient Tensor","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"target_one = generate_gravitational(123, 100)\ntarget_two = generate_vortex(124, 100)\n\nsource_one = generate_gravitational(125, 100)\n\nfmm.fmm!((target_one, target_two), source_one, scalar_potential=[true, false],\n    velocity=[true, true], velocity_gradient=[false, false])","category":"page"},{"location":"guided_examples/#Saving-Generated-Trees","page":"Guided Examples","title":"Saving Generated Trees","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"A given fmm! call will typically return a single tree (if performed on the entire system) or two seperate source/target trees (if called on a source and a target). The function call can also be modified to save these trees.","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"\ntarget_filepath = \"target_tree\"\nsource_filepath = \"source_tree\"\n\ntarget_tree, source_tree = fmm.fmm!((target_one, target_two), source_one;\n    save_tree_target=true, save_name_target=target_filepath,\n    save_tree_source=true, save_name_source=source_filepath)","category":"page"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"In a nutshell, FastMultipole operates by forming series expansions of a kernel function, and translating and combining those expansions to obtain optimal compression. You can get a sense for how this works in the following figure.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"<img src=\"multipole_expansions.png\" width=\"660px\"/>","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Here, we see how each body's influence can be expressed as a series expansion. These series expansions can be translated and combined such that an entire cluster of bodies is represented by a single series expansion. This is what is known as a multipole expansion. Multipole expansions only converge outside of a finite radius of convergence, as illustrated by the red dotted line. Multipole expansions can only be used for interactions that are farther apart than this circl. The accuracy of the expansion gets better and better the farther away we go, so we can control the accuracy by imposing a cutoff radius (dotted blue line), and only use multipole expansions for interactions that are farther away than the blue circle. Multipole expansions are very helpful for reducing the cost of the N-body problem; in fact, we can reduce the scaling of the N-body problem to O(NlogN) by only considering multipole expansions.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Local expansions are very similar to multipole expansions, but they converge inside of a finite radius rather than outside. These provide the additional required compression to achieve fully O(N) scaling. In the next figure, we see how local expansions can reduce the number of times an expansion need be evaluated.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"<img src=\"local_expansions.png\" width=\"660px\"/>","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"More details of the fast multipole method (FMM) can be found in the original work by Greengard and Rokhlin.[4]","category":"page"},{"location":"theory/#References","page":"Theory","title":"References","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"N. A. Gumerov, S. Kaneko and R. Duraiswami. Recursive computation of the multipole expansions of layer potential integrals over simplices for efficient fast multipole accelerated boundary elements. Journal of Computational Physics 486, 112118 (2023).\n\n\n\nN. A. Gumerov and R. Duraiswami. Efficient FMM accelerated vortex methods in three dimensions via the Lamb–Helmholtz decomposition. Journal of Computational Physics 240, 310–328 (2013).\n\n\n\nS. DENG, C. JIANG, Y. WANG and H. WANG. Acceleration of unsteady vortex lattice method via dipole panel fast multipole method. Chinese Journal of Aeronautics 34, 265–278 (2021).\n\n\n\nL. Greengard and V. Rokhlin. A fast algorithm for particle simulations. Journal of computational physics 73, 325–348 (1987).\n\n\n\n","category":"page"},{"location":"quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The following tutorial shows how to use FastMultipole to compute the gravitational potential induced by a collection of point masses. It uses data structures located in test/gravitational.jl.","category":"page"},{"location":"quickstart/#Create-a-System","page":"Quick Start","title":"Create a System","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"First, let's create a system of 1000 randomly spaced point masses:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"using Random\nimport FastMultipole as fmm\ngravitational_path = normpath(joinpath(splitdir(pathof(fmm))[1], \"..\", \"test\", \"gravitational.jl\"))\ninclude(gravitational_path)\n\nfunction generate_gravitational(seed, n_bodies; radius_factor=0.1, strength_factor=1.0)\n    Random.seed!(seed)\n    bodies = rand(8,n_bodies)\n    bodies[1:3,:] = rand(3,n_bodies) # body positions\n\n    bodies[4,:] ./= (n_bodies^(1/3)*2) # body radii\n    bodies[4,:] .*= radius_factor\n\n    bodies[5,:] .*= strength_factor # body strengths\n\n    system = Gravitational(bodies)\n    return system\nend\n\nsystem = generate_gravitational(123, 1000)","category":"page"},{"location":"quickstart/#Evaluate-The-Potential-at-Each-Body","page":"Quick Start","title":"Evaluate The Potential at Each Body","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The fmm! function evaluates the gravitational potential induced by system in-place. We can control the tradeoff between performance and accuracy by tuning a handful of parameters for our particular system, but we'll stick with the defaults for this example:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"fmm.fmm!(system)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The resulting potential can then be accessed as a field of system.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"@show system.potential[1,:]","category":"page"},{"location":"quickstart/#Accuracy-of-FMM-Call","page":"Quick Start","title":"Accuracy of FMM Call","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"By using the direct! function, we can check the accuracy of the fmm! call by evaluating the ''N''-body problem naively, without fast multipole acceleration.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"direct_system = deepcopy(system)\ndirect_system.potential .= 0\n\nfmm.direct!(direct_system)\n\npercent_error = abs.((system.potential[1,:] .- direct_system.potential[1,:]) ./ direct_system.potential[1,:])\n\n@show maximum(percent_error)","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = FastMultipole","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [FastMultipole]\nOrder = [:constant, :type, :function]\n# Pages = [\"fmm.jl\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [FastMultipole]\nOrder = [:constant, :type, :function]\n# Pages = [\"fmm.jl\"]","category":"page"},{"location":"reference/#FastMultipole.DerivativesSwitch","page":"Reference","title":"FastMultipole.DerivativesSwitch","text":"DerivativesSwitch\n\nSwitch indicating whether the scalar potential, vector potential, velocity, and/or velocity gradient should be computed for a target system. Information is stored as type parameters, allowing the compiler to compile away if statements.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FastMultipole.DerivativesSwitch-Tuple{Any, Any, Any}","page":"Reference","title":"FastMultipole.DerivativesSwitch","text":"DerivativesSwitch(scalar_potential, velocity, velocity_gradient)\n\nConstructs a tuple of DerivativesSwitch objects.\n\nArguments\n\nscalar_potential::Vector{Bool}: a vector of ::Bool indicating whether the scalar potential should be computed for each target system\nvelocity::Vector{Bool}: a vector of ::Bool indicating whether the velocity should be computed for each target system\nvelocity_gradient::Vector{Bool}: a vector of ::Bool indicating whether the velocity gradient should be computed for each target system\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.DerivativesSwitch-Tuple{Bool, Bool, Bool, Tuple}","page":"Reference","title":"FastMultipole.DerivativesSwitch","text":"DerivativesSwitch(scalar_potential, velocity, velocity_gradient, target_systems)\n\nConstructs a ::Tuple of indentical DerivativesSwitch objects of the same length as target_systems (if it is a ::Tuple), or a single DerivativesSwitch (if target_system is not a ::Tuple)\n\nArguments\n\nscalar_potential::Bool: a ::Bool indicating whether the scalar potential should be computed for each target system\nvelocity::Bool: a ::Bool indicating whether the velocity should be computed for each target system\nvelocity_gradient::Bool: a ::Bool indicating whether the velocity gradient should be computed for each target system\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.DerivativesSwitch-Tuple{Bool, Bool, Bool}","page":"Reference","title":"FastMultipole.DerivativesSwitch","text":"DerivativesSwitch(scalar_potential, velocity, velocity_gradient)\n\nConstructs a single DerivativesSwitch object.\n\nArguments\n\nscalar_potential::Bool: a ::Bool indicating whether the scalar potential should be computed for the target system\nvelocity::Bool: a ::Bool indicating whether the velocity should be computed for the target system\nvelocity_gradient::Bool: a ::Bool indicating whether the velocity gradient should be computed for the target system\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.ExpansionSwitch","page":"Reference","title":"FastMultipole.ExpansionSwitch","text":"ExpansionSwitch\n\nSwitch indicating which expansions should be used:\n\nscalar potential (SP)\nvector potential via Lamb-Helmholtz decomposition (VP)\n\n\n\n\n\n","category":"type"},{"location":"reference/#FastMultipole.MultiBranch","page":"Reference","title":"FastMultipole.MultiBranch","text":"MultiBranch{TF,N} <: Branch{TF}\n\nBranch object used to sort more than one system into an octree. Type parameters represent:\n\nTF: the floating point type (would be a dual number if using algorithmic differentiation)\nN: the number of systems represented\n\nFields\n\nbodies_index::Vector{UnitRange}: vector of unit ranges indicating the index of bodies in each represented system, respectively\nn_branches::Int: number of child branches corresponding to this branch\nbranch_index::UnitRange: indices of this branch's child branches\ni_parent::Int: index of this branch's parent\ni_leaf::Int: if this branch is a leaf, what is its index in its parent <:Tree's leaf_index field\ncenter::Vector{TF}: center of this branch at which its multipole and local expansions are centered\nsource_radius::TF: if this branch is a leaf, distance from center to the outer edge of farthest body contained in this branch; otherwise, this is the distance from center to the corner of its source_box\ntarget_radius::TF: distance from center to the farthest body center contained in this branch\nsource_box::Vector{TF}: vector of length 6 containing the distances from the center to faces of a rectangular prism completely enclosing all bodies with their finite radius in the negative x, positive x, negative y, positive y, negative z, and positive z directions, respectively\ntarget_box::Vector{TF}: vector of length 3 containing the distances from the center to faces of a rectangular prism completely enclosing all body centers in the x, y, and z direction, respectively\nmultipole_expansion::Array{TF,3}: array of size (2,2,) containing the multipole expansion coefficients; the first index indicates real or imaginary, the second index indicates scalar potential or the second component of the Lamb-Helmholtz decomposition, and the third indexk` indicates the expansion coefficient of degree n and order m, as k = p(p+1)2 + m + 1\nlocal_expansion::Array{TF,3}: array of size(2,2,(p+1)(p+2)/2)containing the local expansion coefficients; the first index indicates real or imaginary, the second index indicates scalar potential or the second component of the Lamb-Helmholtz decomposition, and the third indexk` indicates the expansion coefficient of degree n and order m, as k = p(p+1)2 + m + 1\nharmonics::Array{TF,3}: array of size (2,2,(p+1)(p+2)/2) used as storage for regular harmonics, irregular harmonics, or whatever is needed, and is indexed as multipole and local expansions\nlock::ReentrantLock: lock used to avoid data race conditions when modifying this branch or its corresponding bodies\n\n\n\n\n\n","category":"type"},{"location":"reference/#FastMultipole.MultiTree","page":"Reference","title":"FastMultipole.MultiTree","text":"bodies[indexlist] is the same sort operation as performed by the tree sortedbodies[inverseindexlist] undoes the sort operation performed by the tree\n\n\n\n\n\n","category":"type"},{"location":"reference/#FastMultipole.ProbeSystem","page":"Reference","title":"FastMultipole.ProbeSystem","text":"ProbeSystem\n\nConvenience system for defining locations at which the potential, velocity, or velocity gradient may be desired.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FastMultipole.ProbeSystem-Union{Tuple{Array{StaticArraysCore.SVector{3, TF}, 1}}, Tuple{TF}} where TF","page":"Reference","title":"FastMultipole.ProbeSystem","text":"ProbeSystem(positions; kwargs...)\n\nA convenience system constructor for calculating the influence of source systems at locations not already described by a system object. It behaves like a system whose elements induce a null potential field.\n\nArguments\n\npositions::Vector{SVector{3,Float64}}: a vector of position vectors of each probe\n\nOptional Arguments\n\nscalar_potential::Bool: whether or not to compute the scalar potential at each probe location\nvector_potential::Bool: whether or not to compute the vector potential at each probe location\nvelocity::Bool: whether or not to compute the velocity at each probe location\nvelocity_gradient::Bool: whether or not to compute the velocity gradient at each probe location\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.ProbeSystem-Union{Tuple{Matrix{TF}}, Tuple{TF}} where TF","page":"Reference","title":"FastMultipole.ProbeSystem","text":"ProbeSystem(positions; kwargs...)\n\nDispatch of ProbeSystem accepting a matrix of horizontally concatenated column vectors describing the position of each probe. Optional arguments are identical.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.SingleBranch","page":"Reference","title":"FastMultipole.SingleBranch","text":"SingleBranch{TF} <: Branch{TF}\n\nBranch object used to sort a single system into an octree. Type parameters represent:\n\nTF: the floating point type (would be a dual number if using algorithmic differentiation)\n\nFields\n\nbodies_index::UnitRange: unit range indicating the index of bodies in the represented system\nn_branches::Int: number of child branches corresponding to this branch\nbranch_index::UnitRange: indices of this branch's child branches\ni_parent::Int: index of this branch's parent\ni_leaf::Int: if this branch is a leaf, what is its index in its parent <:Tree's leaf_index field\ncenter::Vector{TF}: center of this branch at which its multipole and local expansions are centered\nsource_radius::TF: if this branch is a leaf, distance from center to the outer edge of farthest body contained in this branch; otherwise, this is the distance from center to the corner of its source_box\ntarget_radius::TF: distance from center to the farthest body center contained in this branch\nsource_box::Vector{TF}: vector of length 6 containing the distances from the center to faces of a rectangular prism completely enclosing all bodies with their finite radius in the negative x, positive x, negative y, positive y, negative z, and positive z directions, respectively\ntarget_box::Vector{TF}: vector of length 3 containing the distances from the center to faces of a rectangular prism completely enclosing all body centers in the x, y, and z direction, respectively\nmultipole_expansion::Array{TF,3}: array of size (2,2,) containing the multipole expansion coefficients; the first index indicates real or imaginary, the second index indicates scalar potential or the second component of the Lamb-Helmholtz decomposition, and the third indexk` indicates the expansion coefficient of degree n and order m, as k = p(p+1)2 + m + 1\nlocal_expansion::Array{TF,3}: array of size(2,2,(p+1)(p+2)/2)containing the local expansion coefficients; the first index indicates real or imaginary, the second index indicates scalar potential or the second component of the Lamb-Helmholtz decomposition, and the third indexk` indicates the expansion coefficient of degree n and order m, as k = p(p+1)2 + m + 1\nharmonics::Array{TF,3}: array of size (2,2,(p+1)(p+2)/2) used as storage for regular harmonics, irregular harmonics, or whatever is needed, and is indexed as multipole and local expansions\nlock::ReentrantLock: lock used to avoid data race conditions when modifying this branch or its corresponding bodies\n\n\n\n\n\n","category":"type"},{"location":"reference/#FastMultipole.SortWrapper-Tuple{Any}","page":"Reference","title":"FastMultipole.SortWrapper","text":"SortWrapper(system)\n\nConvenience wrapper for systems whose elements cannot be sorted in-place (e.g. structured grids). The resulting object is treated like any other system.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.Tree","page":"Reference","title":"FastMultipole.Tree","text":"abstract type Tree{TF,P} end\n\nSupertype of all octree structures with TF the floating point type and P the expansion order.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FastMultipole.EmptyTree-Tuple{Any}","page":"Reference","title":"FastMultipole.EmptyTree","text":"EmptyTree(system)\n\nReturns an empty tree. Used if system is empty.\n\nArguments\n\nsystem: the system from which a tree is to be created\n\nReturns\n\ntree: if typeof(system)<:Tuple, a ::MultiTree is returned; otherwise, a ::SingleTree is returned\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.accumulate_charge!-Union{Tuple{TF}, Tuple{AbstractVector{<:Branch{TF}}, Any, Any}} where TF","page":"Reference","title":"FastMultipole.accumulate_charge!","text":"accumulate_charge!(branches, systems, branch_index)\n\nComputes the sum of the absolute value of body source strengths, as well as the sum of the L2 norm of the dipole strengths, and store them in each branch, inheriting values from child branches if available.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.accumulate_charge_bodies!-Union{Tuple{TF}, Tuple{Array{SingleBranch{TF}, 1}, Any, Any}} where TF","page":"Reference","title":"FastMultipole.accumulate_charge_bodies!","text":"accumulate_charge!(branch, systems)\n\nComputes the sum of the absolute value of body source strengths, as well as the sum of the L2 norm of the dipole strengths, based on source bodies directly, and store them in each branch.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.add_line!-Tuple{ProbeSystem, Vararg{Any, 4}}","page":"Reference","title":"FastMultipole.add_line!","text":"add_line!(probes::ProbeSystem, x1, x2, n_probes, i_last)\n\nAdds n_probes probes in a line between x1 and x2. Specifically, they are added at the midpoint of equally partiti    oned segments of the line.\n\nArguments\n\nprobes::ProbeSystem: the probe system whose .position field is to be updated\nx1::Vector{Float64}: the first point defining the line along which probes are to be added\nx2::Vector{Float64}: the second point defining the line along which probes are to be added\nn_probes::Int: number of probes to be added\ni_last::Int: index of the last probe in probes\n\nOutput\n\ni_last::Int: updated index of the last probe in probes\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.back_rotate_local_y!-NTuple{7, Any}","page":"Reference","title":"FastMultipole.back_rotate_local_y!","text":"Assumes Ts, Hsπ2, and ηsmag have all been precomputed. Resets target_weights.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.back_rotate_multipole_y!-NTuple{6, Any}","page":"Reference","title":"FastMultipole.back_rotate_multipole_y!","text":"Assumes Ts, Hsπ2, and ζsmag have all been precomputed. Resets target_weights.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.back_rotate_z!-Union{Tuple{LH}, Tuple{Any, Any, Any, Any, Val{LH}}} where LH","page":"Reference","title":"FastMultipole.back_rotate_z!","text":"Assumes eimϕs have already been computed. DOES NOT overwrite rotated weights (unlike other rotate functions); rather, accumulates on top of it.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.calculate_ib!-Union{Tuple{P}, Tuple{Any, Any, Any, Any, Any, Any, Val{P}}} where P","page":"Reference","title":"FastMultipole.calculate_ib!","text":"assumes j has already been calculated\n\nNote: if X0real is replaced with X0real + Xw_real, etc., this becomes bnm (as used for volumes) instead of inm (as used for panels)\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.calculate_pj!-Union{Tuple{P}, Tuple{Any, Any, Any, Any, Any, Any, Val{P}}} where P","page":"Reference","title":"FastMultipole.calculate_pj!","text":"assumes q has already been calculated\n\nIf X0real is replaced with X0real + Xv_real, etc., the result becomes jnm instead of pnm, as used for panels.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.d2rdx2-Tuple{Any, Any, Any}","page":"Reference","title":"FastMultipole.d2rdx2","text":"drk/dxidx_j\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.direct!-Tuple{Any, Any}","page":"Reference","title":"FastMultipole.direct!","text":"direct!(target_system, source_system; derivatives_switches)\n\nApplies all interactions of source_system acting on target_system without multipole acceleration.\n\nArguments\n\ntarget_system: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\nsource_system: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\n\nOptional Arguments\n\nscalar_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a scalar potential from source_systems\nvelocity::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity from source_systems\nvelocity_gradient::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity gradient from source_systems\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.direct!-Tuple{Tuple}","page":"Reference","title":"FastMultipole.direct!","text":"direct!(systems; derivatives_switches)\n\nApplies all interactions of systems acting on itself without multipole acceleration.\n\nArguments\n\nsystems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\n\nOptional Arguments\n\nscalar_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a scalar potential from source_systems\nvelocity::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity from source_systems\nvelocity_gradient::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity gradient from source_systems\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.drdx-Tuple{Any, Any, Any}","page":"Reference","title":"FastMultipole.drdx","text":"drj/dxi\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.fmm!-Union{Tuple{Any}, Tuple{PE}} where PE","page":"Reference","title":"FastMultipole.fmm!","text":"fmm!(systems; kwargs...)\n\nApply all interactions of systems acting on itself using the fast multipole method. Assumes compatibility functions have been overloaded for both source and target systems.\n\nArguments\n\nsystems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\n\nOptional Arguments\n\nexpansion_order::Int: the expansion order to be used\nleaf_size::Int: maximum number of bodies from systems allowed in a leaf-level branch\nmultipole_threshold::Float64: number between 0 and 1 (often denoted theta in [0,1]) controls the accuracy by determining the non-dimensional distance after which multipoles are used; 0 means an infinite distance (no error, high cost), and 1 means barely convergent (high error, low cost)\nscalar_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(systems) indicating whether each system should receive a scalar potential from source_systems\nvelocity::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(systems) indicating whether each system should receive a velocity from source_systems\nvelocity_gradient::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(systems) indicating whether each system should receive a velocity gradient from source_systems\nupward_pass::Bool: whether or not to form the multipole expansions from source bodies and translate them upward in the source tree\nhorizontal_pass::Bool: whether or not to transform multipole expansions from the source tree into local expansions in the target tree\ndownward_pass::Bool: whether or not to translate local expansions down to the leaf level of the target tree and evaluate them\nnearfield::Bool: indicates whether near-field (comuted without multipoles) interactions should be included in the direct_list\nfarfield::Bool: indicates whether far-field (comuted with multipoles) interactions should be included in the m2l_list\nself_induced::Bool: indicates whether to include the interactions of each leaf-level branch on itself in the direct_list\nunsort_bodies::Bool: indicates whether or not to undo the sort operation used to generate the octree for systems\nshink_recenter::Bool: indicates whether or not to resize branches for the octree after it is created to increase computational efficiency\nsave_tree::Bool: indicates whether or not to save a VTK file for visualizing the octree\nsave_name::String: name and path of the octree visualization if save_tree == true\nnearfield_device::Bool: indicates whether or not the nearfield_device! function should be used for nearfield interactions\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.fmm!-Union{Tuple{PE}, Tuple{Any, Any}} where PE","page":"Reference","title":"FastMultipole.fmm!","text":"fmm!(target_systems, source_systems; kwargs...)\n\nApply all interactions of source_systems acting on target_systems using the fast multipole method. Assumes compatibility functions have been overloaded for both source and target systems.\n\nArguments\n\ntarget_systems: either\na system object for which compatibility functions have been overloaded, or - a tuple of system objects for which compatibility functions have been overloaded\nsource_systems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\n\nOptional Arguments\n\nexpansion_order::Int: the expansion order to be used\nleaf_size_source::Int: maximum number of bodies from source_systems allowed in a leaf-level branch\nleaf_size_target::Int: maximum number of bodies from target_systems allowed in a leaf-level branch\nmultipole_threshold::Float64: number between 0 and 1 (often denoted theta in [0,1]) controls the accuracy by determining the non-dimensional distance after which multipoles are used; 0 means an infinite distance (no error, high cost), and 1 means barely convergent (high error, low cost)\nlamb_helmholtz::Bool: determines whether or not to calculate the induced velocity due to a vector potential using the Lamb-Helmholtz decomposition; erroroneous velocity and gradient will result if lamb_helmholtz==false and a vector potential is used.\nscalar_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a scalar potential from source_systems\nvelocity::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity from source_systems\nvelocity_gradient::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity gradient from source_systems\nupward_pass::Bool: whether or not to form the multipole expansions from source bodies and translate them upward in the source tree\nhorizontal_pass::Bool: whether or not to transform multipole expansions from the source tree into local expansions in the target tree\ndownward_pass::Bool: whether or not to translate local expansions down to the leaf level of the target tree and evaluate them\nnearfield::Bool: indicates whether near-field (comuted without multipoles) interactions should be included\nfarfield::Bool: indicates whether far-field (comuted with multipoles) interactions should be included\nself_induced::Bool: indicates whether to include the interactions of each leaf-level branch on itself\nunsort_source_bodies::Bool: indicates whether or not to undo the sort operation used to generate the octree for the source_systems\nunsort_target_bodies::Bool: indicates whether or not to undo the sort operation used to generate the octree for the target_systems\nsource_shink_recenter::Bool: indicates whether or not to resize branches for the source_systems octree after it is created to increase computational efficiency\ntarget_shink_recenter::Bool: indicates whether or not to resize branches for the target_systems octree after it is created to increase computational efficiency\nsave_tree_source::Bool: indicates whether or not to save a VTK file for visualizing the source octree\nsave_tree_target::Bool: indicates whether or not to save a VTK file for visualizing the target octree\nsave_name_source::String: name and path of the source octree visualization if save_tree == true\nsave_name_target::String: name and path of the target octree visualization if save_tree == true\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.fmm!-Union{Tuple{PE}, Tuple{Tree, Any, Any, Any, Any, Val}} where PE","page":"Reference","title":"FastMultipole.fmm!","text":"fmm!(tree, systems; kwargs...)\n\nDispatches fmm! using an existing ::Tree.\n\nArguments\n\ntree::Tree: a <:Tree object (see Tree)\nsystems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\nm2l_list::Vector{SVector{2,Int32}}: list of branch index pairs [i_target, i_source] for which multipole expansions of the source branch are to be transformed to local expansions at the target branch\ndirect_list::Union{Vector{SVector{2,Int32}}, InteractionList}: list of branch index pairs [i_target, i_source] for which interactions are to be evaluted without multipole expansion (i.e., directly); if typeof(direct_list) <: InteractionList, then prepared influence matrices are used rather than computing direct influences on the fly\nderivatives_switches::Union{DerivativesSwitch, Tuple{<:DerivativesSwitch,...}}: switch determining which of scalar potential, vector potential, velocity, and/or velocity gradient are to be computed for each target system\n\nOptional Arguments\n\nupward_pass::Bool: whether or not to form the multipole expansions from source bodies and translate them upward in the source tree\nhorizontal_pass::Bool: whether or not to transform multipole expansions from the source tree into local expansions in the target tree\ndownward_pass::Bool: whether or not to translate local expansions down to the leaf level of the target tree and evaluate them\nunsort_bodies::Bool: indicates whether or not to undo the sort operation used to generate the octree for systems\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.fmm!-Union{Tuple{PE}, Tuple{Tree, Any, Tree, Any, Any, Any, Any, Val}} where PE","page":"Reference","title":"FastMultipole.fmm!","text":"fmm!(target_tree, target_systems, source_tree, source_systems, m2l_list, direct_list, derivatives_switches; kwargs...)\n\nDispatches fmm! using existing ::Tree objects.\n\nArguments\n\ntarget_tree::Tree: a <:Tree object (see Tree)\ntarget_systems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\nsource_tree::Tree: a <:Tree object (see Tree)\nsource_systems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\nm2l_list::Vector{SVector{2,Int32}}: list of branch index pairs [i_target, i_source] for which multipole expansions of the source branch are to be transformed to local expansions at the target branch\ndirect_list::Union{Vector{SVector{2,Int32}}, InteractionList}: list of branch index pairs [i_target, i_source] for which interactions are to be evaluted without multipole expansion (i.e., directly); if typeof(direct_list) <: InteractionList, then prepared influence matrices are used rather than computing direct influences on the fly\nderivatives_switches::Union{DerivativesSwitch, Tuple{<:DerivativesSwitch,...}}: switch determining which of scalar potential, vector potential, velocity, and/or velocity gradient are to be computed for each target system\n\nOptional Arguments\n\nmultipole_threshold::Float64: number between 0 and 1 (often denoted theta in [0,1]) controls the accuracy by determining the non-dimensional distance after which multipoles are used; 0 means an infinite distance (no error, high cost), and 1 means barely convergent (high error, low cost)\nscalar_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a scalar potential from source_systems\nvelocity::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity from source_systems\nvelocity_gradient::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity gradient from source_systems\nupward_pass::Bool: whether or not to form the multipole expansions from source bodies and translate them upward in the source tree\nhorizontal_pass::Bool: whether or not to transform multipole expansions from the source tree into local expansions in the target tree\ndownward_pass::Bool: whether or not to translate local expansions down to the leaf level of the target tree and evaluate them\nnearfield::Bool: indicates whether near-field (comuted without multipoles) interactions should be included\nfarfield::Bool: indicates whether far-field (comuted with multipoles) interactions should be included\nself_induced::Bool: indicates whether to include the interactions of each leaf-level branch on itself\nunsort_source_bodies::Bool: indicates whether or not to undo the sort operation used to generate the octree for source_systems\nunsort_target_bodies::Bool: indicates whether or not to undo the sort operation used to generate the octree for target_systems\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.fmm!-Union{Tuple{PE}, Tuple{Tree, Any, Tree, Any}} where PE","page":"Reference","title":"FastMultipole.fmm!","text":"fmm!(target_tree, target_systems, source_tree, source_systems; kwargs...)\n\nDispatches fmm! using existing ::Tree objects.\n\nArguments\n\ntarget_tree::Tree: a <:Tree object (see Tree)\ntarget_systems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\nsource_tree::Tree: a <:Tree object (see Tree)\nsource_systems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\n\nOptional Arguments\n\nmultipole_threshold::Float64: number between 0 and 1 (often denoted theta in [0,1]) controls the accuracy by determining the non-dimensional distance after which multipoles are used; 0 means an infinite distance (no error, high cost), and 1 means barely convergent (high error, low cost)\nscalar_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a scalar potential from source_systems\nvelocity::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity from source_systems\nvelocity_gradient::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity gradient from source_systems\nreset_source_tree::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(source_systems) indicating whether or not to reset the expansions of each source tree\nreset_target_tree::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(source_systems) indicating whether or not to reset the expansions of each target tree\nupward_pass::Bool: whether or not to form the multipole expansions from source bodies and translate them upward in the source tree\nhorizontal_pass::Bool: whether or not to transform multipole expansions from the source tree into local expansions in the target tree\ndownward_pass::Bool: whether or not to translate local expansions down to the leaf level of the target tree and evaluate them\nnearfield::Bool: indicates whether near-field (computed without multipoles) interactions should be included in the direct_list\nfarfield::Bool: indicates whether far-field (computed with multipoles) interactions should be included in the m2l_list\nself_induced::Bool: indicates whether to include the interactions of each leaf-level branch on itself in the direct_list\nunsort_source_bodies::Bool: indicates whether or not to undo the sort operation used to generate the octree for source_systems\nunsort_target_bodies::Bool: indicates whether or not to undo the sort operation used to generate the octree for target_systems\nnearfield_device::Bool: indicates whether or not the nearfield_device! function should be used for nearfield interactions\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.fmm!-Union{Tuple{PE}, Tuple{Tree, Any}} where PE","page":"Reference","title":"FastMultipole.fmm!","text":"fmm!(tree, systems; kwargs...)\n\nDispatches fmm! using an existing ::Tree.\n\nArguments\n\ntree::Tree: a <:Tree object (see Tree)\nsystems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\n\nOptional Arguments\n\nmultipole_threshold::Float64: number between 0 and 1 (often denoted theta in [0,1]) controls the accuracy by determining the non-dimensional distance after which multipoles are used; 0 means an infinite distance (no error, high cost), and 1 means barely convergent (high error, low cost)\nscalar_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(systems) indicating whether each system should receive a scalar potential from source_systems\nvelocity::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(systems) indicating whether each system should receive a velocity from source_systems\nvelocity_gradient::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(systems) indicating whether each system should receive a velocity gradient from source_systems\nupward_pass::Bool: whether or not to form the multipole expansions from source bodies and translate them upward in the source tree\nhorizontal_pass::Bool: whether or not to transform multipole expansions from the source tree into local expansions in the target tree\ndownward_pass::Bool: whether or not to translate local expansions down to the leaf level of the target tree and evaluate them\nnearfield::Bool: indicates whether near-field (computed without multipoles) interactions should be included in the direct_list\nfarfield::Bool: indicates whether far-field (computed with multipoles) interactions should be included in the m2l_list\nself_induced::Bool: indicates whether to include the interactions of each leaf-level branch on itself in the direct_list\nunsort_bodies::Bool: indicates whether or not to undo the sort operation used to generate the octree for systems\nnearfield_device::Bool: indicates whether or not the nearfield_device! function should be used for nearfield interactions\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.get_P-Tuple{Any, Any, Any, Any, Any, Any, Any, Union{EqualSpheres, UnequalBoxes, UnequalSpheres}}","page":"Reference","title":"FastMultipole.get_P","text":"get_P(r_min, r_max, ρ_min, ρ_max, ΔC2, Pmax, ε_rel, error_method)\n\nReturns the smallest expansion order not greater than Pmax and satisfying the specified relative error tolerance.\n\nInputs\n\nr_min::Flaot64: distance from the multipole expansion to the closest target\nr_max::Float64: distance from the local expansion to the farthest target\nρ_min::Float64: distance from the local expansion to the closest source\nρ_max::Float64: distance from the multipole expansion to the farthest source\nΔC2::Float64: distance squared between multipole and local centers\nPmax::Int64: maximum allowable expansion order\nε_rel::Float64: relative error tolerance\nerror_method::ErrorMethod: type used to dispatch on the desired error method\n\nOuputs\n\nP::Int: the smallest expansion order to satisfy the error tolerance\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.local_to_local!-Union{Tuple{LH}, Tuple{P}, Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Val{P}, Val{LH}}} where {P, LH}","page":"Reference","title":"FastMultipole.local_to_local!","text":"Expects ηsmag and Hsπ2 to be precomputed. Ts and eimϕs are computed here.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.mirrored_source_to_vortex!-Union{Tuple{P}, Tuple{Any, Any, Any, Any, Any, Val{P}}} where P","page":"Reference","title":"FastMultipole.mirrored_source_to_vortex!","text":"my novel derivation\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.multipole_to_local!-Union{Tuple{LH}, Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Val{LH}}} where LH","page":"Reference","title":"FastMultipole.multipole_to_local!","text":"Expects ζsmag, ηsmag, and Hs_π2 to be computed a priori.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.nearfield_device!-Tuple{Any, Any, Any}","page":"Reference","title":"FastMultipole.nearfield_device!","text":"nearfield_device!(target_systems, derivatives_switches, source_systems)\n\nDispatches nearfield_device! without having to build a ::Tree. Performs all interactions.\n\nArguments\n\ntarget_systems: user-defined system on which source_system acts\nderivatives_switches::Union{DerivativesSwitch, NTuple{N,DerivativesSwitch}}: determines whether the scalar potential, velocity, and or velocity gradient should be calculated\nsource_systems: user-defined system acting on target_system\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.nearfield_device!-Tuple{Any, Tree, Any, Any, Tree, Any}","page":"Reference","title":"FastMultipole.nearfield_device!","text":"nearfield_device!(target_systems, target_tree, derivatives_switches, source_systems, source_tree, direct_list)\n\nUser-defined function used to offload nearfield calculations to a device, such as GPU.\n\nArguments\n\ntarget_systems: user-defined system on which source_system acts\ntarget_tree::Tree: octree object used to sort target_systems\nderivatives_switches::Union{DerivativesSwitch, NTuple{N,DerivativesSwitch}}: determines whether the scalar potential, velocity, and or velocity gradient should be calculated\nsource_systems: user-defined system acting on target_system\nsource_tree::Tree: octree object used to sort target_systems\ndirect_list::Vector{SVector{2,Int32}}: each element [i,j] maps nearfield interaction from source_tree.branches[j] on target_tree.branches[i]\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.reset!-Tuple{ProbeSystem}","page":"Reference","title":"FastMultipole.reset!","text":"reset!(probes)\n\nZeroes all values (e.g. scalar/vector potential, velocity, and/or velocity gradient) of all probes.\n\nArguments\n\nprobes::ProbeSystem: a ::ProbeSystem object\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.resort!-Tuple{Tuple, MultiTree}","page":"Reference","title":"FastMultipole.resort!","text":"Performs the same sort operation as the tree. (Undoes unsort! operation.)\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.rotate_multipole_y!-NTuple{8, Any}","page":"Reference","title":"FastMultipole.rotate_multipole_y!","text":"Rotate solid harmonic weights about the y axis by θ. Note that Hsπ2 and ζsmag must be updated a priori, but Ts is updated en situ. Resets rotated_weights before computing.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.rotate_z!-Union{Tuple{LH}, Tuple{Any, Any, Any, Any, Any, Val{LH}}} where LH","page":"Reference","title":"FastMultipole.rotate_z!","text":"Performs a z-axis rotation of the supplied solid harmonic coefficients. Computes e^{imϕ} as well.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.shrink_branch!-Tuple{Any, Any, Any}","page":"Reference","title":"FastMultipole.shrink_branch!","text":"Computes the smallest bounding box to completely bound all child boxes.\n\nShrunk radii are merely the distance from the center to the corner of the box.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.source_to_dipole!-Union{Tuple{P}, Tuple{Any, Any, Any, Any, Any, Any, Val{P}}} where P","page":"Reference","title":"FastMultipole.source_to_dipole!","text":"assumes source expansion coefficients have already been calculated\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.source_to_vortex_point!-Union{Tuple{P}, Tuple{Any, Any, Any, Any, Any, Any, Val{P}}} where P","page":"Reference","title":"FastMultipole.source_to_vortex_point!","text":"might be slightly faster than mirroredsourceto_vortex\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.translate_local_z!-Union{Tuple{LH}, Tuple{Any, Any, Any, Any, Val{LH}}} where LH","page":"Reference","title":"FastMultipole.translate_local_z!","text":"Overwrites translated_weights\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.translate_multipole_to_local_z!-Union{Tuple{LH}, Tuple{Any, Any, Any, Any, Val{LH}}} where LH","page":"Reference","title":"FastMultipole.translate_multipole_to_local_z!","text":"Overwrites translated_weights\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.translate_multipole_z!-Union{Tuple{LH}, Tuple{Any, Any, Any, Any, Val{LH}}} where LH","page":"Reference","title":"FastMultipole.translate_multipole_z!","text":"Overwrites translated_weights\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.unsort!-Tuple{Tuple, MultiTree}","page":"Reference","title":"FastMultipole.unsort!","text":"Undoes the sort operation performed by the tree.\n\n\n\n\n\n","category":"method"},{"location":"#FastMultipole","page":"Introduction","title":"FastMultipole","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A fast, multi-system, multi-kernel, differentiable implementation of the fast multipole method for use with scalar-plus-vector potential N-body problems in pure Julia.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Author: Ryan Anderson","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Features:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"solves N-body problems governed by the Laplace (1r) kernel, with work planned to support the Helmholtz kernel in the future\nincorporates seamlessly into existing Julia code without modifications (just the addition of a few interface functions)\noffers convenience functions for determining the expansion coefficients for source points, vortex points, source panels, and dipole panels (this list is growing!)\nprovides velocity and velocity gradient (or their equivalent for non-fluids problems) obtained using analytic expressions (no finite difference)\nuses O(p^4) multipole-to-local translation operator (where p is the expansion order), though this may improve in the near future\nautomated CPU-parallelization of expansions and direct interactions\nsupports GPU-parallelization of direct interactions using CUDA\nForwardDiff and ReverseDiff compatible","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Installation:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add https://github.com/byuflowlab/FastMultipole.git","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Documentation:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"learn basic useage in the Quick Start tutorial\ndiscover more features in the Guided Examples\nfine-tune performance in the Advanced Usage section (for FMM experts)\nsee the full API\nbrush up on the Theory","category":"page"}]
}
