var documenterSearchIndex = {"docs":
[{"location":"advanced_usage/#Advanced-Usage","page":"Advanced Usage","title":"Advanced Usage","text":"","category":"section"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"The most advanced features of FastMultipole include:","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"the ability to solve the n-body problem for multiple systems simultaneously in a single FMM call\nsatisfy an error tolerance by dynamically adjusting the expansion order of multipole-to-local transformations\npredict the full array of FMM tuning parameters such that an error tolerance is met","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"In this section, we will first describe how to run the FMM for multi-system problems. Then, we will describe how to impose an error tolerance. Finally, we will show how to automatically tune the FMM parameters.","category":"page"},{"location":"advanced_usage/#Simultaneous-Computation-of-Multiple-and-Distinct-Source-and-Target-Systems","page":"Advanced Usage","title":"Simultaneous Computation of Multiple and Distinct Source and Target Systems","text":"","category":"section"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"FastMutipole allows FMM to be performed efficiently on distinct source and target systems. This is done by creating two octrees: one for sources, and one for targets [3]. For example, say we desire to know the influence of one system of point masses on another, but not vice versa. This is done by passing both systems to the fmm! function with the target system first, as:","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"using FastMultipole\nusing Random # needed for `gravitational.jl`\n\ngravitational_path = normpath(joinpath(splitdir(pathof(FastMultipole))[1], \"..\", \"test\", \"gravitational.jl\"))\ninclude(gravitational_path)\n\ntarget_system = generate_gravitational(123, 1000)\nsource_system = generate_gravitational(321, 1000)\n\nfmm!(target_system, source_system)","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"In practice, the source system might be a collection of systems, composed of a variety of datastructures. So long as the interface functions are defined for each system, we can pass a tuple of any number of systems as the source and or target. For example, we could evaluate the influence of a system of point masses, point vortices, and vortex filaments on two different target systems:","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"using LinearAlgebra\n\n# include vortex filament and particle models and interface functions\nvortex_path = normpath(joinpath(splitdir(pathof(FastMultipole))[1], \"..\", \"test\", \"vortex.jl\"))\ninclude(vortex_path)\nfilament_path = normpath(joinpath(splitdir(pathof(FastMultipole))[1], \"..\", \"test\", \"vortex_filament.jl\"))\ninclude(filament_path)\n\n# generate systems\nn_bodies = 2000\ntarget_one = generate_gravitational(123, n_bodies)\ntarget_two = generate_vortex(124, n_bodies)\nsource_one = generate_gravitational(125, n_bodies)\nsource_two = generate_vortex(126, n_bodies)\nsource_three = generate_filament_field(n_bodies, n_bodies^0.333, 127; strength_scale=1/n_bodies)\n\n# run FMM\nfmm!((target_one, target_two), (source_one, source_two, source_three); lamb_helmholtz=true,\n    scalar_potential=false, gradient=true, hessian=(false, true))\n\nv1 = target_one.potential[5:7,:]\nv2 = target_two.gradient_stretching[1:3,:]\n\n# run direct\ntarget_one.potential .= 0.0\ntarget_two.potential .= 0.0\ntarget_two.gradient_stretching .= 0.0\ndirect!((target_one, target_two), (source_one, source_two, source_three); scalar_potential=false, gradient=true, hessian=(false, true))\n\n# test accuracy\nprintln(\"Max error in target one: \", maximum(abs.(target_one.potential[5:7,:] .- v1)))\nprintln(\"Max error in target two: \", maximum(abs.(target_two.gradient_stretching[1:3,:] .- v2)))","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"Note that scalar_potential, gradient, and hessian can be passed as a single boolean or as a tuple of booleans, one for each target system. This allows the user to specify which values are desired for each target system, and avoids unnecessary calculations for values that are not needed. In this case, we have set scalar_potential=false and gradient=true to indicate all target systems, but a tuple hessian=(false,true) to indicate different settings for each. It is worth remembering that these switches must be implemented by the user when overloading the direct! function for each system to act as a source.","category":"page"},{"location":"advanced_usage/#Satisfying-an-Error-Tolerance","page":"Advanced Usage","title":"Satisfying an Error Tolerance","text":"","category":"section"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"FastMultipole can be configured to satisfy an error tolerance by dynamically adjusting the expansion order of each multipole-to-local transformation to the smallest integer that satisfies the tolerance, according to an error prediction. Users can indicate their desired error tolerance via the keyword argument ε_tol in the fmm! function. A value of nothing indicates no error tolerance, in which case the expansion order is fixed at whatever is passed as the expansion_order keyword. Otherwise, ε_tol should inherit from the ErrorMethod abstract type. The chosen type will determine how the error is predicted, and hence how the expansion order is chosen. Choices include:","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"PowerAbsolutePotential{tolerance}: Constrains the magnitude of the potential error to be less than tolerance using a radially invariant upper bound.\nPowerAbsoluteGradient{tolerance}: Constrains the magnitude of the vector field error to be less than tolerance using a radially invariant upper bound.\nPowerRelativePotential{tolerance}: Constrains the relative error of the potential to be less than tolerance using a radially invariant upper bound.\nPowerRelativeGradient{tolerance}: Constrains the relative error of the vector field to be less than tolerance using a radially invariant upper bound.","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"Say I wanted to compute the gravitational potential to a tolerance of 1e-4 using the absolute potential error method. I would call the FMM as follows:","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"# create system\nn_bodies, rand_seed = 50_000, 123\nsystem = generate_gravitational(rand_seed, n_bodies)\n\n# run FMM with error tolerance\nfmm!(system; lamb_helmholtz=false, scalar_potential=true, gradient=false, hessian=false, ε_tol=PowerAbsolutePotential(1e-4))","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"This keyword argument ε_tol=PowerAbsolutePotential(1e-4) requests that the expansion order be dynamically adjusted to ensure that the potential error of each interaction is less than 1e-4 at each body. Note that this does ensure a perfectly conservative error bound, since many multipole-to-local transformations will be performed to any given target cell. However, the maximum error should be within an order of magnitude of the specified tolerance, and the average error will be much lower.","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"# verify error\nphi_fmm = system.potential[1,:]\nsystem.potential .= 0.0\ndirect!(system; scalar_potential=true, gradient=false, hessian=false)\nphi_direct = system.potential[1,:]\nprintln(\"Max error in potential: \", maximum(abs.(phi_direct .- phi_fmm)))","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"It is also worth noting that the error methods used here sometimes fail for coarse tolerances. Let's see what happens when we try to use a tolerance of 1e-2:","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"# run FMM with error tolerance\nsystem.potential .= 0.0\nfmm!(system; lamb_helmholtz=false, scalar_potential=true, gradient=false, hessian=false, ε_tol=PowerAbsolutePotential(1e-2))\n\n# check error\nphi_fmm = system.potential[1,:]\nprintln(\"Max error in potential: \", maximum(abs.(phi_direct .- phi_fmm)))","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"As a rule of thumb, care should be taken if 2 digits of accuracy or less is requested. The methods employed are fairly robust for 3 or more digits of accuracy. PowerAbsolutePotential and PowerAbsoluteGradient are best when the maximum error is to be constrained, while RotatedCoefficientsAbsoluteGradient is better if the mean error is to be constrained.","category":"page"},{"location":"advanced_usage/#Fully-Automatic-Tuning-of-FMM-Parameters","page":"Advanced Usage","title":"Fully Automatic Tuning of FMM Parameters","text":"","category":"section"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"FastMultipole can automatically tune the FMM parameters to satisfy an error tolerance. This is done by running the tune_fmm function, which returns a named tuple of the optimal parameters and a preallocated buffer to reduce memory allocations.","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"Say I wanted the optimal tuning parameters for the gravitational potential of a system of point masses, with a maximum error tolerance of 1e-4. I would call the function as follows:","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"opt_params, cache = tune_fmm(system; ε_tol=PowerAbsolutePotential(1e-4), lamb_helmholtz=false, scalar_potential=true, gradient=false, hessian=false)\nprintln(\"Optimal parameters: \", opt_params)","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"This will return a named tuple of the optimal parameters, which can then be passed to the fmm! function. The cache is a preallocated buffer that can be used to reduce memory allocations during the FMM call.","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"# run FMM without default parameters\nsystem.potential .= 0.0\n@time fmm!(system; lamb_helmholtz=false, scalar_potential=true, gradient=false, hessian=false, ε_tol=PowerAbsolutePotential(1e-4))\n\n# verify error\nphi_fmm = system.potential[1,:]\nprintln(\"Max error in potential without tuning: \", maximum(abs.(phi_direct .- phi_fmm)))\n\n# run FMM with optimal parameters\n@time fmm!(system; lamb_helmholtz=false, scalar_potential=true, gradient=false, hessian=false, ε_tol=PowerAbsolutePotential(1e-4), cache..., opt_params...)\n\n# verify error\nprintln(\"Max error in potential: \", maximum(abs.(phi_direct .- phi_fmm)))","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"Note that the tune_fmm function iterates over each requested multipole_acceptance criterion, so it is not optimal to call it before every FMM call. Instead, tune_fmm can be called once for a representative system primarily to choose multipole_acceptance. Since the optimal parameters depend on the size, distribution, and strengths of the sources and targets, it is recommended to set the keyword argument tune=true to iteratively update the expansion_order and leaf_size_source parameters each time fmm! is called. This will allow the FMM to adapt to the system as it evolves, and will ensure that the optimal parameters are used for each call.","category":"page"},{"location":"guided_examples/#Guided-Examples","page":"Guided Examples","title":"Guided Examples","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"FastMultipole is designed to incorporate easily into your existing Julia code with minimal effort. In particular, several interface functions must be defined. We'll walk through the process in the following guided examples.","category":"page"},{"location":"guided_examples/#Gravitational-Example","page":"Guided Examples","title":"Gravitational Example","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"In this example, we review the interface functions used by the gravitational point mass model used in Quick Start. This code can also be found under FastMultipole/test/gravitational.jl.","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"To better understand how the FastMultipole interface functions, let's take a look at the data structures we'll use to define our point masses:","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"using FastMultipole\nusing FastMultipole.StaticArrays\n\nconst i_POTENTIAL = 1:1   # index of the gravitational potential\nconst i_GRADIENT = 5:7    # index of the gravitational acceleration\nconst i_HESSIAN = 8:16    # index of the hessian matrix\n\n# a single point mass\nstruct Body{TF}\n    position::SVector{3,TF}\n    radius::TF\n    strength::SVector{4,TF}\nend\n\n# container for a system of `Body`'s\nstruct Gravitational{TF}\n    bodies::Vector{Body{TF}}\n    potential::Matrix{TF}\nend\n\n# constructor\nfunction Gravitational(bodies::Matrix)\n    nbodies = size(bodies)[2]\n    bodies2 = [Body(SVector{3}(bodies[1:3,i]),bodies[4,i],SVector{4}(bodies[5:8,i])) for i in 1:nbodies]\n    potential = zeros(52,nbodies)\n    return Gravitational(bodies2,potential)\nend","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"In short, Body objects represent individual point masses, and the Gravitational object contains a group of them, along with a matrix of the potential, velocity, and velocity gradient at each body. The observant reader will notice that the strength field of Body is a 4-vector. The first index contains the mass of the body, used to induce a gravitational potential. The final three indices are meant to contain a vector strength, in case a vector potential is desired. For the sake of simplicy, we will assume strength[2:4] is zero for now. ","category":"page"},{"location":"guided_examples/#Overloading-body_to_multipole!","page":"Guided Examples","title":"Overloading body_to_multipole!","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"The function body_to_multipole! is used to generate multipole expansions for our particular system. This is done be overloading FastMultipole.body_to_multipole! for our data structure. Convenience functions exist within FastMultipole to simplify this complicated function into a one-liner:","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"FastMultipole.body_to_multipole!(system::Gravitational, args...) =\n    FastMultipole.body_to_multipole!(Point{Source}, system, args...)","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"The ::Gravitational type annotation is the key that allows FastMultipole to dispatch on ::Gravitational systems. Point{Source} is used to indicate that our bodies are points and induce a source (i.e. 1r) potential. Other convenience functions exist in FastMultipole for any combination of Point, Filament, or Panel geometries using Source, Dipole, or Vortex kernels, and are specified when overloading body_to_multipole! as <geometry>{<kernel>}. For example, if my model used constant vortex sheet panels, I would replace Point{Source} in the example above to Panel{Vortex}.","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"We use the fast recursive method of generating exact coefficients for panels as developed by [1]. We have derived our own formulae for vortex filaments and panels, which are in the process of publication.","category":"page"},{"location":"guided_examples/#Buffer-Interface-Functions","page":"Guided Examples","title":"Buffer Interface Functions","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"FastMultipole allocates a buffer matrix in which to sort and store key system information. The buffer interface is created by overloading several functions for the user-defined system type. The first of these functions is FastMultipole.source_system_to_buffer!, which populates a matrix with the important information about each body, column-wise. Overloading for ::Gravitational systems looks like this:","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"function FastMultipole.source_system_to_buffer!(buffer, i_buffer, system::Gravitational, i_body)\n    buffer[1:3, i_buffer] .= system.bodies[i_body].position\n    buffer[4, i_buffer] = system.bodies[i_body].radius\n    buffer[5, i_buffer] = system.bodies[i_body].strength[1]\nend","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"Here, the i_bodyth body position, radius, and strength are copied to the correct positions in the i_bufferth column of the buffer matrix.","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"It is worth noting that there are ways of defining these functions that would harm performance, e.g. by allocating an array each time the velocity is requested. If you notice FastMultipole's performance is poor, this and the other interface functions are good places to check.","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"Because every system can have a unique buffer structure, we need to overload a few additional functions to tell FastMultipole how to allocate and access it. The first function, data_per_body, returns the number of rows in the buffer matrix that are used to define a single body. The second function, get_position, returns the position of the ith body in the system. The third function, strength_dims, returns the number of rows in the buffer matrix that are used to define the strength of a single body. Finally, we overload get_n_bodies to return the number of bodies in our system. For our Gravitational system, we define:","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"Base.eltype(::Gravitational{TF}) where TF = TF\n\nfunction FastMultipole.data_per_body(system::Gravitational)\n    return 5\nend\n\nfunction FastMultipole.get_position(system::Gravitational, i)\n    return system.bodies[i].position\nend\n\nfunction FastMultipole.strength_dims(system::Gravitational)\n    return 1\nend\n\nFastMultipole.get_n_bodies(system::Gravitational) = length(system.bodies)","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"These functions provide enough information for FastMultipole to allocate the buffer matrix and access the data it needs.","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"Finally, we need to tell FastMultipole how to transfer the results of the FMM call back to the user-defined system. This is done by overloading the FastMultipole.buffer_to_target_system! function. Overloading for ::Gravitational systems looks like this:","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"function FastMultipole.buffer_to_target_system!(target_system::Gravitational, i_target, ::FastMultipole.DerivativesSwitch{PS,VS,GS}, target_buffer, i_buffer) where {PS,VS,GS}\n    # get values\n    TF = eltype(target_buffer)\n    scalar_potential = PS ? FastMultipole.get_scalar_potential(target_buffer, i_buffer) : zero(TF)\n    velocity = VS ? FastMultipole.get_gradient(target_buffer, i_buffer) : zero(SVector{3,TF})\n    hessian = GS ? FastMultipole.get_hessian(target_buffer, i_buffer) : zero(SMatrix{3,3,TF,9})\n\n    # update system\n    target_system.potential[i_POTENTIAL[1], i_target] = scalar_potential\n    target_system.potential[i_GRADIENT, i_target] .= velocity\n    for (jj,j) in enumerate(i_HESSIAN)\n        target_system.potential[j, i_target] = hessian[jj]\n    end\nend","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"We note that the convenience functions get_velocity and get_hessian return ::SVector{3} and ::SMatrix{3,3}, respectively, to reduce allocations.","category":"page"},{"location":"guided_examples/#Overloading-direct!","page":"Guided Examples","title":"Overloading direct!","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"The last required interface function is FastMultipole.direct!, which evaluates the potential at a target system using a source system without multipole acceleration. This is required in an FMM call for those interactions that are too close to be approximated by expansions. It is also useful for debugging and testing the accuracy of the FMM call. Overloading for ::Gravitational systems, we have:","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"function FastMultipole.direct!(target_system, target_index, ::DerivativesSwitch{PS,VS,GS}, source_system::Gravitational, source_buffer, source_index) where {PS,VS,GS}\n    @inbounds for i_source in source_index\n        source_x, source_y, source_z = FastMultipole.get_position(source_buffer, i_source)\n        source_strength = FastMultipole.get_strength(source_buffer, source_system, i_source)[1]\n        @inbounds for j_target in target_index\n            target_x, target_y, target_z = FastMultipole.get_position(target_system, j_target)\n            dx = target_x - source_x\n            dy = target_y - source_y\n            dz = target_z - source_z\n            r2 = dx*dx + dy*dy + dz*dz\n            if r2 > 0\n                r = sqrt(r2)\n                if PS\n                    dϕ = source_strength / r * FastMultipole.ONE_OVER_4π\n                    FastMultipole.set_scalar_potential!(target_system, j_target, dϕ)\n                end\n                if VS\n                    dF = SVector{3}(dx,dy,dz) * source_strength / (r2 * r) * FastMultipole.ONE_OVER_4π\n                    FastMultipole.set_gradient!(target_system, j_target, dF)\n                end\n            end\n        end\n    end\nend","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"Note that the velocity gradient is not calculated in this function. If the velocity gradient is requested, the contribution due to ::Gravitational systems will then be zero.","category":"page"},{"location":"guided_examples/#Running-the-FMM","page":"Guided Examples","title":"Running the FMM","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"Now that we have defined the interface functions, we can run the FMM on our Gravitational system. The fmm! function is used to perform the FMM call. For example,","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"using Random\n\n# create system\nfunction generate_gravitational(seed, n_bodies; radius_factor=0.1, strength_scale=1/n_bodies, bodies_fun=(x)->x)\n    Random.seed!(seed)\n    bodies = rand(8,n_bodies)\n    # bodies = rand(distribution,8,n_bodies)\n    bodies[4,:] ./= (n_bodies^(1/3)*2)\n    bodies[4,:] .*= radius_factor\n    bodies[5,:] .*= strength_scale\n\n    bodies_fun(bodies)\n\n    system = Gravitational(bodies)\nend\n\nn_bodies, rand_seed = 1000, 123\nsystem = generate_gravitational(rand_seed, n_bodies)\n\n# run FMM\nfmm!(system; lamb_helmholtz=false, scalar_potential=false, gradient=true, hessian=true)","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"We have supplied lamb_helmholtz=false to the FMM call because the gravitational potential is a scalar potential and does not require the Lamb-Helmholtz decomposition of a vector field. This is not strictly necessary, since the predicted potential would be identical regardless. However, it does provide a slight performance benefit by omitting the Lamb-Helmholtz operators. The scalar_potential and gradient arguments are set to false and true, respectively, to indicate that we want to compute the vector field (i.e. the gravitational field lines that translate to force and their gradient) but not the scalar potential.","category":"page"},{"location":"guided_examples/#Preallocating-the-Buffers","page":"Guided Examples","title":"Preallocating the Buffers","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"The fmm! function incurs a small overhead for allocating the buffer matrices. If our system is large and the FMM will be called more than once, we can preallocate the buffers to avoid this overhead. This is done by returning the buffer cache the first time fmm! is called, and then splatting it as an optional argument to fmm! in subsequent calls as follows:","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"# allocate buffer cache\nprintln(\"#--- allocating benchmark ---#\\n\")\n@time _, cache, _ = fmm!(system; lamb_helmholtz=false, scalar_potential=false, gradient=true, hessian=true)\n\n# run FMM with preallocated buffers\nprintln(\"\\n#--- preallocated benchmark ---#\\n\")\n@time fmm!(system; lamb_helmholtz=false, scalar_potential=false, gradient=true, hessian=true, cache...)","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"Note that the second call to fmm! allocates less memory.","category":"page"},{"location":"guided_examples/#Tuning-Parameters","page":"Guided Examples","title":"Tuning Parameters","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"The FMM can be tuned for accuracy and performance by adjusting the following parameters: multipole_acceptance, leaf_size, and expansion_order. These parameters are passed to the fmm! function as keyword arguments. Let's take a look at how each affects the FMM:","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"# create system\nn_bodies, rand_seed = 1000, 123\nsystem = generate_gravitational(rand_seed, n_bodies)\n\n# compute potential directly\ndirect!(system; gradient=true)\ngradient_direct = system.potential[5:7,:]\n\n# try varying `expansion_order`\nprintln(\"#--- varying expansion order ---#\\n\")\nprintln(\"\\texpansion_order = 3\")\nfmm!(system; expansion_order=1, multipole_acceptance=0.5, leaf_size=30, gradient=true)\nsystem.potential .= 0.0\n@time fmm!(system; expansion_order=3, multipole_acceptance=0.5, leaf_size=30, gradient=true)\nprintln(\"\\t\\tmax error = \", maximum(abs.(system.potential[5:7,:] .- gradient_direct)))\n\nprintln(\"\\n\\texpansion_order = 8\")\nsystem.potential .= 0.0\n@time fmm!(system; expansion_order=5, multipole_acceptance=0.5, leaf_size=30, gradient=true)\nprintln(\"\\t\\tmax error = \", maximum(abs.(system.potential[5:7,:] .- gradient_direct)))\n\nprintln(\"\\n\\texpansion_order = 12\")\nsystem.potential .= 0.0\n@time fmm!(system; expansion_order=10, multipole_acceptance=0.5, leaf_size=30, gradient=true)\nprintln(\"\\t\\tmax error = \", maximum(abs.(system.potential[5:7,:] .- gradient_direct)))\n\n# try varying `multipole_acceptance`\nprintln(\"\\n#--- varying multipole acceptance ---#\\n\")\nprintln(\"\\n\\tmultipole_acceptance = 0.2\")\nsystem.potential .= 0.0\n@time fmm!(system; expansion_order=4, multipole_acceptance=0.4, leaf_size=30, gradient=true)\nprintln(\"\\t\\tmax error = \", maximum(abs.(system.potential[5:7,:] .- gradient_direct)))\nprintln(\"\\n\\tmultipole_acceptance = 0.4\")\nsystem.potential .= 0.0\n@time fmm!(system; expansion_order=4, multipole_acceptance=0.4, leaf_size=30, gradient=true)\nprintln(\"\\t\\tmax error = \", maximum(abs.(system.potential[5:7,:] .- gradient_direct)))\nprintln(\"\\n\\tmultipole_acceptance = 0.8\")\nsystem.potential .= 0.0\n@time fmm!(system; expansion_order=4, multipole_acceptance=0.8, leaf_size=30, gradient=true)\nprintln(\"\\t\\tmax error = \", maximum(abs.(system.potential[5:7,:] .- gradient_direct)))\n\n# try varying `leaf_size`\nprintln(\"\\n#--- varying leaf size ---#\\n\")\nprintln(\"\\n\\tleaf_size = 1\")\nsystem.potential .= 0.0\n@time fmm!(system; expansion_order=4, multipole_acceptance=0.5, leaf_size=10, gradient=true)\nprintln(\"\\t\\tmax error = \", maximum(abs.(system.potential[5:7,:] .- gradient_direct)))\nprintln(\"\\n\\tleaf_size = 10\")\nsystem.potential .= 0.0\n@time fmm!(system; expansion_order=4, multipole_acceptance=0.5, leaf_size=10, gradient=true)\nprintln(\"\\t\\tmax error = \", maximum(abs.(system.potential[5:7,:] .- gradient_direct)))\nprintln(\"\\n\\tleaf_size = 80\")\nsystem.potential .= 0.0\n@time fmm!(system; expansion_order=4, multipole_acceptance=0.5, leaf_size=80, gradient=true)\nprintln(\"\\t\\tmax error = \", maximum(abs.(system.potential[5:7,:] .- gradient_direct)))","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"This example demonstrates some trends of how each parameter affects the  The expansion_order parameter is always positively correlated to accuracy but negatively correlated to cost. The parameters multipole_acceptance and leaf_size are still correlated, but less predictably so. This motivates automated tuning of the parameters. We'll explore that more in the next example.","category":"page"},{"location":"guided_examples/#Vortex-Filament-Example","page":"Guided Examples","title":"Vortex Filament Example","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"In this example, we review the interface functions used by the vortex filament model found in FastMultipole/test/vortex_filament.jl. First, let's take a look at the data structure:","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"struct VortexFilaments{TF}\n    x::Matrix{SVector{3,TF}}\n    strength::Vector{SVector{3,TF}}\n    core_size::Vector{TF}\n    ε_tol::Vector{TF}\n    potential::Vector{TF}\n    force::Vector{SVector{3,TF}}\n    gradient::Vector{SMatrix{3,3,TF,9}}\nend","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"Note that x is a 2-row matrix, where the first row contains the start point of the filament and the second row contains the end point. The strength field contains the strength of the vortex filament, which is a vector quantity. The core_size field contains the regularization radius for each filament. The potential, force, and gradient fields are used to store the results of the FMM call.","category":"page"},{"location":"guided_examples/#Overloading-body_to_multipole!-2","page":"Guided Examples","title":"Overloading body_to_multipole!","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"Just like we did for the gravitational example, we need to overload FastMultipole.body_to_multipole! for our vortex filament system. The recommended way to do this is:","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"FastMultipole.body_to_multipole!(system::VortexFilaments, args...) = \n    FastMultipole.body_to_multipole!(Filament{Vortex}, system, args...)","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"Ordinarily, a 3-dimensional vector potential, such as the stream function in 3-dimensional fluid dynamics, requires 3 separate expansions (1 for each dimension). It is worth noting that when Vortex elements are used, FastMultipole never actually computes the vector potential vecpsi; rather, it computes two scalar components phi and chi of the Lamb-Helmholtz decomposition of the field as demonstrated by [2]. This allows us to reduce the number of expansions required to express the scalar-plus-vector potential from 4 to 2, thus reducing computational cost. It is also worth noting that phi and chi are not coordinate system-invariant fields, and thus cannot be used to evaluate scalar or vector potentials. In other words, when a Vortex kernel is used as a source in a FMM call, the scalar_potential should not be used.","category":"page"},{"location":"guided_examples/#Buffer-Interface-Functions-2","page":"Guided Examples","title":"Buffer Interface Functions","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"The buffer interface functions are defined for VortexFilament systems as follows:","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"function FastMultipole.source_system_to_buffer!(buffer, i_buffer, system::VortexFilaments, i_body)\n    # position\n    buffer[1:3,i_buffer] .= (system.x[1,i_body]  + system.x[2,i_body]) * 0.5\n    \n    # get regularization radius\n    Γ = system.strength[i_body]\n    # Γmag = norm(Γ)\n    core_size = system.core_size[i_body]\n    buffer[4,i_buffer] = system.core_size[i_body] + 0.5 * norm(system.x[2,i_body] - system.x[1,i_body])\n\n    # remainding quantities\n    buffer[5:7,i_buffer] .= Γ\n    buffer[8:10,i_buffer] .= system.x[1,i_body]\n    buffer[11:13,i_buffer] .= system.x[2,i_body]\n    buffer[14,i_buffer] = core_size\nend\n\nBase.eltype(::VortexFilaments{TF}) where TF = TF\n\nFastMultipole.data_per_body(::VortexFilaments) = 14\n\nFastMultipole.get_position(system::VortexFilaments, i) = (system.x[1,i] + system.x[2,i]) * 0.5\n\nFastMultipole.strength_dims(system::VortexFilaments) = 3\n\nFastMultipole.get_n_bodies(system::VortexFilaments) = length(system.strength)\n\nfunction FastMultipole.buffer_to_target_system!(target_system::VortexFilaments, i_target, ::DerivativesSwitch{PS,VS,GS}, target_buffer, i_buffer) where {PS,VS,GS}\n\n    # extract from buffer\n    PS && (potential = FastMultipole.get_scalar_potential(target_buffer, i_buffer))\n    VS && (velocity = FastMultipole.get_gradient(target_buffer, i_buffer))\n    GS && (hessian = FastMultipole.get_hessian(target_buffer, i_buffer))\n\n    # load into system\n    PS && (target_system.potential[i_target] += potential)\n    VS && (target_system.force[i_target] += velocity)\n    GS && (target_system.gradient[i_target] += hessian)\n\nend","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"First, we point out that the source_system_to_buffer! function stores a core size in row 14. Although it will not be used by any internal FastMultipole functions, it will be required by the direct! function. Since the columns of the buffer are sorted into an octree structure, they will not match the order of the original system; therefore, it is important to store essential body properties in additional rows of the buffer. We also note that the get_position function needs not return a previously-stored value; in this case, it computes the midpoint of the filament on the fly.","category":"page"},{"location":"guided_examples/#Overloading-direct!-2","page":"Guided Examples","title":"Overloading direct!","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"The FastMultipole.direct! function is overloaded for VortexFilaments systems as follows:","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"function get_δ(distance, core_size)\n    δ = distance < core_size ? (distance-core_size) * (distance-core_size) : zero(distance)\n    return δ\nend\n\nfunction vortex_filament_finite_core_2(x1,x2,xt,q,core_size)\n    # intermediate values\n    r1 = xt - x1\n    r2 = xt - x2\n\n    nr1 = norm(r1)\n    nr2 = norm(r2)\n\n    num = cross(r1, r2)\n    denom = nr1 * nr2 + dot(r1, r2)\n\n    # core size comes into play here\n    distance_1 = norm((x1+x2)*0.5 - xt)\n    δ1 = get_δ(distance_1, core_size)\n\n    distance_2 = norm(x1 - xt)\n    δ2 = get_δ(distance_2, core_size)\n\n    distance_3 = norm(x2 - xt)\n    δ3 = get_δ(distance_3, core_size)\n\n    # desingularized terms\n    f1 = num/(denom + δ1)\n    f2 = 1/(nr1+δ2)\n    f3 = 1/(nr2+δ3)\n\n    # evaluate velocity\n    V = (f1*(f2+f3))/(4*pi) * q\n\n    return V\nend\n\nfunction FastMultipole.direct!(target_system, target_index, derivatives_switch::DerivativesSwitch{PS,VS,GS}, source_system::VortexFilaments, source_buffer, source_index) where {PS,VS,GS}\n    for i_source in source_index\n        x1 = FastMultipole.get_vertex(source_buffer, source_system, i_source, 1)\n        x2 = FastMultipole.get_vertex(source_buffer, source_system, i_source, 2)\n        q = FastMultipole.get_strength(source_buffer, source_system, i_source)\n        core_size = source_buffer[14, i_source]\n\n        for i_target in target_index\n            xt = FastMultipole.get_position(target_system, i_target)\n\n            if VS\n                # determine sign of q\n                q_mag = norm(q) * sign(dot(q, x2-x1))\n\n                # calculate velocity\n                v = vortex_filament_finite_core_2(x1,x2,xt,q_mag,core_size)\n                FastMultipole.set_gradient!(target_system, i_target, v)\n            end\n        end\n    end\nend","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"Note that core_size is retrieved from the buffer matrix rather than from source_system directly, as discussed previously.","category":"page"},{"location":"guided_examples/#Running-the-FMM-2","page":"Guided Examples","title":"Running the FMM","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"Let's try this out on a vortex filament system. The fmm! function is called in the same way as for the gravitational example, but with the VortexFilaments system:","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"using LinearAlgebra\n\n# create system\nfunction generate_filament_field(n_filaments, length_scale; strength_scale=1/n_filaments)\n    centers = rand(SVector{3,Float64}, n_filaments)\n    pts = zeros(SVector{3,Float64}, 2, n_filaments)\n    strength_vec= zeros(SVector{3,Float64}, n_filaments)\n    for (i,center) in enumerate(centers)\n        dx = (rand(SVector{3,Float64}) * 2 .- 1.0) * 0.5 * length_scale\n        pts[1,i] = center - dx\n        pts[2,i] = center + dx\n        Γ = dx / norm(dx) * rand() * strength_scale\n        strength_vec[i] = Γ\n    end\n\n    # create filaments\n    core_size = fill(1e-2, n_filaments)\n    ε_tol = fill(1e-4, n_filaments)\n    potential = zeros(length(strength_vec))\n    gradient = zeros(SVector{3,Float64}, length(strength_vec))\n    hessian = zeros(SMatrix{3,3,Float64,9}, length(strength_vec))\n\n    return VortexFilaments(pts, strength_vec, core_size, ε_tol, potential, gradient, hessian)\nend\n\nn_filaments = 1000\nlength_scale = 1.0 / n_filaments^(1/3)\nfilaments = generate_filament_field(n_filaments, length_scale; strength_scale=1/n_filaments)\n\n# run FMM\n_, cache, _ = fmm!(filaments; lamb_helmholtz=true, scalar_potential=false, gradient=true)","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"We set lamb_helmholtz=true because the vortex filament model induces a vector potential.","category":"page"},{"location":"guided_examples/#Optimal-Leaf-Size","page":"Guided Examples","title":"Optimal Leaf Size","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"We can request FastMultipole to predict the optimal leaf size for our system by setting tune=true in the fmm! call. This performs best when interaction_list_method=SelfTuning() on a single thread, but still functions well for other choices. If tune=true, benchmarks will be used to estimate the leaf size at which the cost of direct calculations is approximately equal to expansion calculations. It is returned as part of a named tuple as the first returned value of fmm!, which can be splatted as a keyword argument in subsequent fmm! calls:","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"# get optimal leaf size\nprintln(\"#--- default leaf size ---#\\n\")\n@time optargs, _ = fmm!(filaments; tune=true, lamb_helmholtz=true, scalar_potential=false, gradient=true, cache...)\n\n# run again with optimal leaf size\nprintln(\"\\n#--- optimal leaf size ---#\\n\")\n@time fmm!(filaments; lamb_helmholtz=true, scalar_potential=false, gradient=true, cache..., optargs...)","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"Note that optargs contains leaf_size_source, expansion_order, and multipole_acceptance parameters. Only leaf_size_source is tuned if isnothing(ε_tol) == true. More complete auto-tuning will be discussed later.","category":"page"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"In a nutshell, FastMultipole operates by forming series expansions of a kernel function, and translating and combining those expansions to obtain optimal compression. You can get a sense for how this works in the following figure.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"<img src=\"../assets/multipole_expansions.png\" width=\"660px\"/>","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Here, we see how each body's influence can be expressed as a series expansion. These series expansions can be translated and combined such that an entire cluster of bodies is represented by a single series expansion. This is what is known as a multipole expansion. Multipole expansions only converge outside of a finite radius of convergence, as illustrated by the red dotted line. Multipole expansions can only be used for interactions that are farther apart than this circl. The accuracy of the expansion gets better and better the farther away we go, so we can control the accuracy by imposing a cutoff radius (dotted blue line), and only use multipole expansions for interactions that are farther away than the blue circle. Multipole expansions are very helpful for reducing the cost of the N-body problem; in fact, we can reduce the scaling of the N-body problem to O(NlogN) by only considering multipole expansions.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Local expansions are very similar to multipole expansions, but they converge inside of a finite radius rather than outside. These provide the additional required compression to achieve fully O(N) scaling. In the next figure, we see how local expansions can reduce the number of times an expansion need be evaluated.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"<img src=\"../assets/local_expansions.png\" width=\"660px\"/>","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"More details of the fast multipole method (FMM) can be found in the original work by Greengard and Rokhlin.[4]","category":"page"},{"location":"theory/#References","page":"Theory","title":"References","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"N. A. Gumerov, S. Kaneko and R. Duraiswami. Recursive computation of the multipole expansions of layer potential integrals over simplices for efficient fast multipole accelerated boundary elements. Journal of Computational Physics 486, 112118 (2023).\n\n\n\nN. A. Gumerov and R. Duraiswami. Efficient FMM accelerated vortex methods in three dimensions via the Lamb–Helmholtz decomposition. Journal of Computational Physics 240, 310–328 (2013).\n\n\n\nR. Yokota. An FMM based on dual tree traversal for many-core architectures. Journal of Algorithms & Computational Technology 7, 301–324 (2013).\n\n\n\nL. Greengard and V. Rokhlin. A fast algorithm for particle simulations. Journal of computational physics 73, 325–348 (1987).\n\n\n\n","category":"page"},{"location":"quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The following tutorial shows how to use FastMultipole to compute the gravitational potential induced by a collection of point masses. It uses data structures located in test/gravitational.jl.","category":"page"},{"location":"quickstart/#Create-a-System","page":"Quick Start","title":"Create a System","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"First, let's create a system of 1000 randomly spaced point masses:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"using FastMultipole\nusing Random # needed for `gravitational.jl`\n\ngravitational_path = normpath(joinpath(splitdir(pathof(FastMultipole))[1], \"..\", \"test\", \"gravitational.jl\"))\ninclude(gravitational_path)\n\nrand_seed = 123\nn_bodies = 1000\nsystem = generate_gravitational(rand_seed, n_bodies)","category":"page"},{"location":"quickstart/#Evaluate-The-Potential-at-Each-Body","page":"Quick Start","title":"Evaluate The Potential at Each Body","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The fmm! function evaluates the gravitational potential induced by system in-place. We can control the tradeoff between performance and accuracy with a handful of tuning parameters, but we'll stick with the defaults for this example:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"fmm!(system)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The resulting potential can then be accessed in the user-defined system object.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"@show system.potential[1,:]","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Let me emphasize that system can be any user-defined object, so long as a few interface functions are defined (we'll go over those later). This allows you to use FastMultipole in your existing code with almost no modifications.","category":"page"},{"location":"quickstart/#Accuracy-of-FMM-Call","page":"Quick Start","title":"Accuracy of FMM Call","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"By using the direct! function, we can check the accuracy of the fmm! call by evaluating the ''N''-body problem naively, without fast multipole acceleration.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"direct_system = deepcopy(system)\ndirect_system.potential .= 0.0\n\ndirect!(direct_system)\n\npercent_error = abs.((system.potential[1,:] .- direct_system.potential[1,:]) ./ direct_system.potential[1,:])\n\n@show maximum(percent_error)","category":"page"},{"location":"quickstart/#Scalar-plus-Vector-Potential-Applications","page":"Quick Start","title":"Scalar-plus-Vector Potential Applications","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The use of a scalar-plus-vector potential is quite general, and is useful in a variety of physics and engineering contexts, including fluid dynamics, linear elasticity, electromagnetism, astrophysics, and others. We include a table of some common field quantities that derive from the scalar-plus-vector potential, along with their corresponding fmm! keyword arguments and physical interpretations.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"vecv = nabla phi + nabla times vecpsi","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":" phi vecpsi vecv nabla vecv\nfmm! Keyword Arguments scalar_potential vector_potential gradient hessian\nFluid Dynamics Scalar Potential Stream Function Fluid Velocity Velocity Gradient\nElectrostatics Electric Potential - Electric Field Field Gradient Tensor\nMagnetostatics - Magnetic Vector Potential Magnetic Field Field Gradient Tensor\nAstrophysics Gravitational Potential - Gravitational Acceleration Acceleration Gradient Tensor","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [FastMultipole]\nOrder = [:constant, :type, :function]\n# Pages = [\"fmm.jl\"]","category":"page"},{"location":"reference/#FastMultipole.Branch","page":"Reference","title":"FastMultipole.Branch","text":"Branch{TF,N}\n\nBranch object used to sort more than one system into an octree. Type parameters represent:\n\nTF: the floating point type (would be a dual number if using algorithmic differentiation)\nN: the number of systems represented\n\nFields\n\nbodies_index::Vector{UnitRange}: vector of unit ranges indicating the index of bodies in each represented system, respectively\nn_branches::Int: number of child branches corresponding to this branch\nbranch_index::UnitRange: indices of this branch's child branches\ni_parent::Int: index of this branch's parent\ni_leaf::Int: if this branch is a leaf, what is its index in its parent <:Tree's leaf_index field\ncenter::Vector{TF}: center of this branch at which its multipole and local expansions are centered\nsource_radius::TF: if this branch is a leaf, distance from center to the outer edge of farthest body contained in this branch; otherwise, this is the distance from center to the corner of its source_box\ntarget_radius::TF: distance from center to the farthest body center contained in this branch\nsource_box::Vector{TF}: vector of length 6 containing the distances from the center to faces of a rectangular prism completely enclosing all bodies with their finite radius in the negative x, positive x, negative y, positive y, negative z, and positive z directions, respectively\ntarget_box::Vector{TF}: vector of length 3 containing the distances from the center to faces of a rectangular prism completely enclosing all body centers in the x, y, and z direction, respectively\nmax_influence::TF: maximum influence of any body in this branch on any body in its child branches; used to enforce a relative error tolerance\n\n\n\n\n\n","category":"type"},{"location":"reference/#FastMultipole.DerivativesSwitch","page":"Reference","title":"FastMultipole.DerivativesSwitch","text":"DerivativesSwitch\n\nSwitch indicating whether the scalar potential, vector potential, gradient, and/or hessian should be computed for a target system. Information is stored as type parameters, allowing the compiler to compile away if statements.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FastMultipole.DerivativesSwitch-Tuple{Any, Any, Any}","page":"Reference","title":"FastMultipole.DerivativesSwitch","text":"DerivativesSwitch(scalar_potential, gradient, hessian)\n\nConstructs a tuple of DerivativesSwitch objects.\n\nArguments\n\nscalar_potential::Vector{Bool}: a vector of ::Bool indicating whether the scalar potential should be computed for each target system\ngradient::Vector{Bool}: a vector of ::Bool indicating whether the vector field should be computed for each target system\nhessian::Vector{Bool}: a vector of ::Bool indicating whether the vector gradient should be computed for each target system\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.DerivativesSwitch-Tuple{Bool, Bool, Bool, Tuple}","page":"Reference","title":"FastMultipole.DerivativesSwitch","text":"DerivativesSwitch(scalar_potential, gradient, hessian, target_systems)\n\nConstructs a ::Tuple of indentical DerivativesSwitch objects of the same length as target_systems (if it is a ::Tuple), or a single DerivativesSwitch (if target_system is not a ::Tuple)\n\nArguments\n\nscalar_potential::Bool: a ::Bool indicating whether the scalar potential should be computed for each target system\ngradient::Bool: a ::Bool indicating whether the vector field should be computed for each target system\nhessian::Bool: a ::Bool indicating whether the vector gradient should be computed for each target system\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.DerivativesSwitch-Tuple{Bool, Bool, Bool}","page":"Reference","title":"FastMultipole.DerivativesSwitch","text":"DerivativesSwitch(scalar_potential, gradient, hessian)\n\nConstructs a single DerivativesSwitch object.\n\nArguments\n\nscalar_potential::Bool: a ::Bool indicating whether the scalar potential should be computed for the target system\ngradient::Bool: a ::Bool indicating whether the vector field should be computed for the target system\nhessian::Bool: a ::Bool indicating whether the vector gradient should be computed for the target system\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.ExpansionSwitch","page":"Reference","title":"FastMultipole.ExpansionSwitch","text":"ExpansionSwitch\n\nSwitch indicating which expansions should be used:\n\nscalar potential (SP)\nvector potential via Lamb-Helmholtz decomposition (VP)\n\n\n\n\n\n","category":"type"},{"location":"reference/#FastMultipole.ProbeSystem","page":"Reference","title":"FastMultipole.ProbeSystem","text":"ProbeSystem\n\nConvenience system for defining locations at which the potential, vector field, or vector gradient may be desired.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FastMultipole.Tree","page":"Reference","title":"FastMultipole.Tree","text":"bodies[indexlist] is the same sort operation as performed by the tree sortedbodies[inverseindexlist] undoes the sort operation performed by the tree\n\n\n\n\n\n","category":"type"},{"location":"reference/#FastMultipole.EmptyTree-Tuple{Any}","page":"Reference","title":"FastMultipole.EmptyTree","text":"EmptyTree(system)\n\nReturns an empty tree. Used if system is empty.\n\nArguments\n\nsystem: the system from which a tree is to be created\n\nReturns\n\ntree: if typeof(system)<:Tuple, a ::MultiTree is returned; otherwise, a ::SingleTree is returned\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.TreeByLevel-Tuple{Tuple, Bool}","page":"Reference","title":"FastMultipole.TreeByLevel","text":"Doesn't stop subdividing until ALL child branches have satisfied the leaf size.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole._rotate_multipole_y_n!-Union{Tuple{LH}, Tuple{Any, Any, Any, Any, Any, Val{LH}, Any, Any, Any}} where LH","page":"Reference","title":"FastMultipole._rotate_multipole_y_n!","text":"The first time this function is called, it should receive iζ=0, iT=0, and n=0. It will return iζ and iT appropriate for n+1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.allocate_buffers-Tuple{Tuple, Bool}","page":"Reference","title":"FastMultipole.allocate_buffers","text":"allocate_buffers(systems::Tuple, target::Bool)\n\nAllocates buffers for the given systems. If target is true, it allocates space for position, scalar potential, gradient, and hessian matrix. Otherwise, it allocates enough memory for the user-defined source_system_to_buffer!.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.allocate_small_buffers-Tuple{Tuple}","page":"Reference","title":"FastMultipole.allocate_small_buffers","text":"allocate_small_buffers(systems::Tuple; target=false)\n\nAllocates small buffers for the given systems. These buffers are used for temporary storage of body positions for octree sorting.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.back_rotate_local_y!-NTuple{7, Any}","page":"Reference","title":"FastMultipole.back_rotate_local_y!","text":"Assumes Ts, Hsπ2, and ηsmag have all been precomputed. Resets target_weights.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.back_rotate_multipole_y!-NTuple{6, Any}","page":"Reference","title":"FastMultipole.back_rotate_multipole_y!","text":"Assumes Ts, Hsπ2, and ζsmag have all been precomputed. Resets target_weights.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.back_rotate_z!-Union{Tuple{LH}, Tuple{Any, Any, Any, Any, Val{LH}}} where LH","page":"Reference","title":"FastMultipole.back_rotate_z!","text":"Assumes eimϕs have already been computed. DOES NOT overwrite rotated weights (unlike other rotate functions); rather, accumulates on top of it.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.body_to_multipole!-NTuple{7, Any}","page":"Reference","title":"FastMultipole.body_to_multipole!","text":"body_to_multipole!(system::{UserDefinedSystem}, multipole_coefficients, buffer, expansion_center, bodies_index, harmonics, expansion_order)\n\nCalculates the multipole coefficients due to the bodies contained in buffer[:,bodies_index] and accumulates them in multipole_coefficients. Should be overloaded for each user-defined system object (where {UserDefinedSystem} is replaced with the type of the user-defined system).\n\nTypically, this is done using one of the convience functions contained within FastMultipole in one line, as\n\nbody_to_multipole!(system::MySystem, args...) = body_to_multipole!(Point{Vortex}, system, args...)\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.buffer_to_system_strength!-NTuple{4, Any}","page":"Reference","title":"FastMultipole.buffer_to_system_strength!","text":"buffer_to_system_strength!(system::{UserDefinedSystem}, source_buffer::Matrix{Float64}, i_body::Int)\n\nNOTE: this function is primarily used for the boundary element solver, and is not required for the FMM.\n\nUpdates the strength in system for the i_bodyth body using the strength information contained in source_buffer. Should be overloaded for each user-defined system object used with the boundary element solver.\n\nArguments:\n\nsystem::{UserDefinedSystem}: the user-defined system object\ni_body::Int: the index of the body in source_system whose strength is to be set\nsource_buffer::Matrix{Float64}: the source buffer containing the body information\ni_buffer::Int: the index of the body in source_buffer whose strength is to be set\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.buffer_to_target_system!-NTuple{5, Any}","page":"Reference","title":"FastMultipole.buffer_to_target_system!","text":"buffer_to_target_system!(target_system::{UserDefinedSystem}, i_target, ::DerivativesSwitch{PS,GS,HS}, target_buffer, i_buffer) where {PS,GS,HS}\n\nCompatibility function used to update target systems. It should be overloaded for each system (where {UserDefinedSystem} is replaced with the type of the user-defined system) to be a target and should behave as follows. For the i_bodyth body contained inside of target_system,\n\ntarget_buffer[4, i_buffer] contains the scalar potential influence to be added to the i_target body of target_system\ntarget_buffer[5:7, i_buffer] contains the vector field influence to be added to the i_target body of target_system\ntarget_buffer[8:16, i_buffer] contains the vector field gradient to be added to the i_target body of target_system\n\nNote that any system acting only as a source (and not as a target) need not overload buffer_to_target_system!.\n\nThe following convenience functions can may be used to access the buffer:\n\nget_scalar_potential(target_buffer, i_buffer::Int): returns the scalar potential induced at the i_buffer body in target_buffer\nget_gradient(target_buffer, i_buffer::Int): returns an SVector of length 3 containing the vector field induced at the i_buffer body in target_buffer\nget_hessian(target_buffer, i_buffer::Int): returns an SMatrix of size 3x3 containing the vector gradient induced at the i_buffer body in target_buffer\n\nFor some slight performance improvements, the booleans PS, GS, and HS can be used as a switch to indicate whether the scalar potential, vector field, and vector gradient are to be stored, respectively. Since they are compile-time parameters, if statements relying on them will not incur a runtime cost.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.calculate_ib!-NTuple{7, Any}","page":"Reference","title":"FastMultipole.calculate_ib!","text":"assumes j has already been calculated\n\nNote: if X0real is replaced with X0real + Xw_real, etc., this becomes bnm (as used for volumes) instead of inm (as used for panels)\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.calculate_pj!-NTuple{7, Any}","page":"Reference","title":"FastMultipole.calculate_pj!","text":"assumes q has already been calculated\n\nIf X0real is replaced with X0real + Xv_real, etc., the result becomes jnm instead of pnm, as used for panels.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.closest_corner-Tuple{Any, Any, StaticArraysCore.SVector{3}}","page":"Reference","title":"FastMultipole.closest_corner","text":"Vector from center 2 to the corner of box2 closest to center.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.d2rdx2-Tuple{Any, Any, Any}","page":"Reference","title":"FastMultipole.d2rdx2","text":"drk/dxidx_j\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.data_per_body-Tuple{Any}","page":"Reference","title":"FastMultipole.data_per_body","text":"data_per_body(system::{UserDefinedSystem})\n\nReturns the number of values used to represent a single body in a source system. Should be overloaded for each user-defined system object (where {UserDefinedSystem} is replaced with the type of the user-defined system).\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.direct!-NTuple{6, Any}","page":"Reference","title":"FastMultipole.direct!","text":"direct!(target_buffer, target_index, derivatives_switch::DerivativesSwitch{PS,GS,HS}, ::{UserDefinedSystem}, source_buffer, source_index) where {PS,GS,HS}\n\nCalculates direct (nearfield) interactions of source_system on target_buffer. Should be overloaded or each user-defined system object (where {UserDefinedSystem} is replaced with the type of the user-defined system), for all source bodies in source_index, at all target bodies in target_index, as follows:\n\n# loop over source bodies\nfor i_source in source_index\n\n    # extract source body information here...\n\n    # loop over target bodies\n    for i_target in target_index\n\n        # get target position\n        target_position = get_position(target_buffer, i_target)\n\n        # evaluate influence here...\n\n        # update appropriate quantities\n        if PS\n            set_scalar_potential!(target_buffer, i_target, scalar_potential)\n        end\n        if GS\n            set_gradient!(target_buffer, i_target, gradient)\n        end\n        if HS\n            set_hessian!(target_buffer, i_target, hessian)\n        end\n\n    end\nend\n\nNote that ::{UserDefinedSystem} is used purely for overloading the method for the appropriate system, and should NOT be accessed in this function, since it will NOT be indexed according to source_index. Rather, source_buffer, which is updated using source_system_to_buffer!, should be accessed.\n\nThe following convenience getter functions are available for accessing the source system:\n\nget_position(source_system::{UserDefinedSystem}, i_body::Int): returns an SVector of length 3 containing the position of the i_body body\nget_strength(source_buffer::Matrix, source_system::{UserDefinedSystem}, i_body::Int): returns an SVector containing the strength of the i_body body\nget_vertex(source_buffer::Matrix, source_system::{UserDefinedSystem}, i_body::Int, i_vertex::Int): returns an SVector containing the x, y, and z coordinates of the i_vertex vertex of the i_body body\n\nNote also that the compile time parameters PS, GS, and HS are used to determine whether the scalar potential and vector field should be computed, respectively. This allows us to skip unnecessary calculations and improve performance.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.direct!-Tuple{Tuple}","page":"Reference","title":"FastMultipole.direct!","text":"direct!(systems; derivatives_switches)\n\nApplies all interactions of systems acting on itself without multipole acceleration.\n\nArguments\n\nsystems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\n\nOptional Arguments\n\nscalar_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a scalar potential from source_systems\ngradient::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a vector field from source_systems\nhessian::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a vector gradient from source_systems\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.drdx-Tuple{Any, Any, Any}","page":"Reference","title":"FastMultipole.drdx","text":"drj/dxi\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.fmm!-Tuple{Tuple, Tuple}","page":"Reference","title":"FastMultipole.fmm!","text":"fmm!(target_systems::Tuple, source_systems::Tuple; optargs...)\n\nDispatches fmm! with automatic tree creation.\n\nArguments\n\ntarget_systems::Union{Tuple, {UserDefinedSystem}}: either a system object for which compatibility functions have been overloaded, or a tuple of system objects for which compatibility functions have been overloaded\nsource_systems::Union{Tuple, {UserDefinedSystem}}: either a system object for which compatibility functions have been overloaded, or a tuple of system objects for which compatibility functions have been overloaded\n\nNote: a convenience function fmm!(system) is provided, which is equivalent to fmm!(system, system).\n\nOptional Arguments: Allocation\n\ntarget_buffers::Vector{<:Any}: buffers for target systems; if not provided, buffers are allocated using allocate_buffers\ntarget_small_buffers::Vector{<:Any}: small buffers for target systems; if not provided, small buffers are allocated using allocate_small_buffers\nsource_buffers::Vector{<:Any}: buffers for source systems; if not provided, buffers are allocated using allocate_buffers\nsource_small_buffers::Vector{<:Any}: small buffers for source systems; if not provided, small buffers are allocated using allocate_small_buffers\n\nOptional Arguments: Tuning Parameters\n\nexpansion_order::Int: order of multipole expansions; default is 5\nmultipole_acceptance::Float64: acceptance criterion for multipole expansions; default is 0.4\nleaf_size_target::Union{Nothing,Int}: leaf size for target systems; if not provided, the minimum of the source leaf sizes is used\nleaf_size_source::Union{Nothing,Int}: leaf size for source systems; if not provided, the default leaf size is used\nε_tol::Union{Nothing,ErrorMethod}: error tolerance for multipole to local translations; if not provided, no error treatment is performed\n\nOptional Arguments: Tree Options\n\nshrink_recenter::Bool: whether to shrink and recenter branches around their bodies, accounting for finite body radius; default is true\ninteraction_list_method::InteractionListMethod: method for building interaction lists; default is SelfTuningTreeStop()\n\nOptional Arguments: Additional Options\n\nfarfield::Bool: whether to compute farfield interactions; default is true\nnearfield::Bool: whether to compute nearfield interactions; default is true\nself_induced::Bool: whether to compute self-induced interactions; default is true\nupward_pass::Bool: whether to perform the upward pass; default is true\nhorizontal_pass::Bool: whether to perform the horizontal pass; default is true\ndownward_pass::Bool: whether to perform the downward pass; default is true\nscalar_potential::Union{Bool,AbstractVector{Bool}}: whether to compute the scalar potential; default is false\ngradient::Union{Bool,AbstractVector{Bool}}: whether to compute the vector field; default is true\nhessian::Union{Bool,AbstractVector{Bool}}: whether to compute the vector gradient; default is false\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.get_n_bodies-Tuple{Any}","page":"Reference","title":"FastMultipole.get_n_bodies","text":"get_n_bodies(system::{UserDefinedSystem})\n\nReturns the number of bodies contained inside system. Should be overloaded for each user-defined system object (where {UserDefinedSystem} is replaced with the type of the user-defined system).\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.get_normal-Tuple{Any, Any, Any}","page":"Reference","title":"FastMultipole.get_normal","text":"get_normal(source_buffer, source_system::{UserDefinedSystem}, i)\n\nOPTIONAL OVERLOAD:\n\nReturns the unit normal vector for the ith body of source_buffer. May be (optionally) overloaded for a user-defined system object (where {UserDefinedSystem} is replaced with the type of the user-defined system); otherwise, the default behavior assumes counter-clockwise ordered vertices. Note that whatever method is used should match source_system_to_buffer! for each system.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.get_position-Tuple{Any, Any}","page":"Reference","title":"FastMultipole.get_position","text":"get_position(system::{UserDefinedSystem}, i)\n\nReturns a (static) vector of length 3 containing the x, y, and z coordinates of the position of the ith body. Should be overloaded for each user-defined system object (where {UserDefinedSystem} is replaced with the type of the user-defined system).\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.index_by_source-Tuple{Vector{StaticArraysCore.SVector{2, Int32}}, Vector{Int64}}","page":"Reference","title":"FastMultipole.index_by_source","text":"index_by_source(sorted_list::Vector{SVector{2,Int}}, leaf_index::Vector{Int})\n\nConstructs an index map that maps each leaf to the range of indices in the sorted list where it acts as a source. It is possible for some leaves to never act as sources, in which case the range will be empty.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.influence!-NTuple{4, Any}","page":"Reference","title":"FastMultipole.influence!","text":"influence!(influence, target_buffer, source_system, source_buffer)\n\nNOTE: source_system is provided solely for dispatch; it's member bodies will be out of order and should not be referenced.\n\nNOTE: This function is primarily used for the boundary element solver, and is not required for the FMM.\n\nEvaluate the influence as pertains to the boundary element influence matrix and overwrites it to influence (which would need to be subtracted for it to act like the RHS of a linear system). Based on the current state of the target_buffer and source_buffer. Should be overloaded for each system type that is used in the boundary element solver.\n\nArguments:\n\ninfluence::AbstractVector{TF}: vector containing the influence for every body in the target buffer\ntarget_buffer::Matrix{TF}: target buffer used to compute the influence\nsource_system::{UserDefinedSystem}: system object used solely for dispatch\nsource_buffer::Matrix{TF}: source buffer used to compute the influence\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.influence!-Union{Tuple{TF}, Tuple{Vector{TF}, Array{Vector{TF}, 1}, Tuple, Tuple, Tuple, Tree}} where TF","page":"Reference","title":"FastMultipole.influence!","text":"influence!(sorted_influences, influences_per_system, target_buffers, source_systems, source_buffers, source_tree)\n\nEvaluate the influence as pertains to the boundary element influence matrix and subtracts it from sorted_influences (which would act like the RHS of a linear system). Based on the current state of the target_buffers and source_buffers. Note that source_systems is provided solely for dispatch. Note also that influences_per_system is overwritten each time.\n\nsorted_influences::Vector{Float64}: single vector containing the influence for every body in the target buffers, sorted by source branch in the direct interaction list\ninfluences_per_system::Vector{Vector{Float64}}: vector of vectors containing the influence for each target system, sorted the same way as the buffers\ntarget_buffers::NTuple{N,Matrix{Float64}}: target buffers used to compute the influence\nsource_systems::NTuple{N,<:{UserDefinedSystem}}: system objects used for dispatch\nsource_buffers::NTuple{N,Matrix{Float64}}: source buffers used to compute the influence\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.local_error-Tuple{Any, Any, Any, Any, Any, FastMultipole.RotatedCoefficients, Val}","page":"Reference","title":"FastMultipole.local_error","text":"Multipole coefficients up to expansion order `P+1` must be added to `multipole_branch` before calling this function.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.local_power-Union{Tuple{LH}, Tuple{Any, Any, Any, Any, Val{LH}}} where LH","page":"Reference","title":"FastMultipole.local_power","text":"performs the lamb-helmholtz transformation assuming that the coordinate system is still aligned with the z axis\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.local_to_local!-Union{Tuple{LH}, Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Val{LH}}} where LH","page":"Reference","title":"FastMultipole.local_to_local!","text":"Expects ηsmag and Hsπ2 to be precomputed. Ts and eimϕs are computed here.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.make_direct_assignments!-NTuple{9, Any}","page":"Reference","title":"FastMultipole.make_direct_assignments!","text":"make_direct_assignments!(assignments, i_target_system, target_branches, i_source_system, source_branches, direct_list, n_threads, n_per_thread, interaction_list_method)\n\nAssumes direct_list is sorted by target branch index. Assigns ranges of interactions to each thread.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.map_by_branch-Tuple{Tree}","page":"Reference","title":"FastMultipole.map_by_branch","text":"map_by_branch(target_tree::Tree)\n\nConstructs a mapping from each branch to the range of indices in the targets vector that correspond to the bodies in that branch.\n\nThis relies on the fact that tree.leaf_index is sorted in order of increasing branch index.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.map_by_leaf-Tuple{Tree}","page":"Reference","title":"FastMultipole.map_by_leaf","text":"map_by_leaf(source_tree::Tree)\n\nConstructs a mapping from each leaf to the range of indices in the strengths vector that correspond to the bodies in that leaf.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.mirrored_source_to_vortex!-NTuple{6, Any}","page":"Reference","title":"FastMultipole.mirrored_source_to_vortex!","text":"my derivation\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.multipole_error-Tuple{Any, Any, Any, Any, Any, FastMultipole.RotatedCoefficients, Val}","page":"Reference","title":"FastMultipole.multipole_error","text":"Multipole coefficients up to expansion order `P+1` must be added to `multipole_branch` before calling this function.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.multipole_to_local!-NTuple{16, Any}","page":"Reference","title":"FastMultipole.multipole_to_local!","text":"defaults to no error prediction\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.multipole_to_local!-Union{Tuple{BE}, Tuple{ε}, Tuple{LH}, Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Val{LH}, PowerAbsoluteGradient{ε, BE}}} where {LH, ε, BE}","page":"Reference","title":"FastMultipole.multipole_to_local!","text":"Expects ζsmag, ηsmag, and Hs_π2 to be computed a priori.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.multipole_to_local!-Union{Tuple{BE}, Tuple{ε}, Tuple{LH}, Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Val{LH}, PowerAbsolutePotential{ε, BE}}} where {LH, ε, BE}","page":"Reference","title":"FastMultipole.multipole_to_local!","text":"Expects ζsmag, ηsmag, and Hs_π2 to be computed a priori.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.multipole_to_local!-Union{Tuple{BE}, Tuple{ε}, Tuple{LH}, Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Val{LH}, RotatedCoefficientsAbsoluteGradient{ε, BE}}} where {LH, ε, BE}","page":"Reference","title":"FastMultipole.multipole_to_local!","text":"Expects ζsmag, ηsmag, and Hs_π2 to be computed a priori.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.multipole_to_local!-Union{Tuple{LH}, Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Val{LH}, Nothing}} where LH","page":"Reference","title":"FastMultipole.multipole_to_local!","text":"Expects ζsmag, ηsmag, and Hs_π2 to be computed a priori.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.nearfield_device!-Tuple{Any, Any, Any}","page":"Reference","title":"FastMultipole.nearfield_device!","text":"nearfield_device!(target_systems, derivatives_switches, source_systems)\n\nDispatches nearfield_device! without having to build a ::Tree. Performs all interactions.\n\nArguments\n\ntarget_systems: user-defined system on which source_system acts\nderivatives_switches::Union{DerivativesSwitch, NTuple{N,DerivativesSwitch}}: determines whether the scalar potential, vector field, and or vector gradient should be calculated\nsource_systems: user-defined system acting on target_system\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.nearfield_device!-Tuple{Any, Tree, Any, Any, Tree, Any}","page":"Reference","title":"FastMultipole.nearfield_device!","text":"nearfield_device!(target_systems, target_tree, derivatives_switches, source_systems, source_tree, direct_list)\n\nUser-defined function used to offload nearfield calculations to a device, such as GPU.\n\nArguments\n\ntarget_systems: user-defined system on which source_system acts\ntarget_tree::Tree: octree object used to sort target_systems\nderivatives_switches::Union{DerivativesSwitch, NTuple{N,DerivativesSwitch}}: determines whether the scalar potential, vector field, and or vector gradient should be calculated\nsource_systems: user-defined system acting on target_system\nsource_tree::Tree: octree object used to sort target_systems\ndirect_list::Vector{SVector{2,Int32}}: each element [i,j] maps nearfield interaction from source_tree.branches[j] on target_tree.branches[i]\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.predict_error-Union{Tuple{LH}, Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Val{LH}, PowerAbsolutePotential}} where LH","page":"Reference","title":"FastMultipole.predict_error","text":"performs a partial M2L for expansion_order+1, and predicts the error along the way;\n\nexpects that the upward pass has been performed up to expansion_order+1\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.rotate_multipole_y!-NTuple{8, Any}","page":"Reference","title":"FastMultipole.rotate_multipole_y!","text":"Rotate solid harmonic weights about the y axis by θ. Note that Hsπ2 and ζsmag must be updated a priori, but Ts is updated en situ. Resets rotated_weights before computing.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.rotate_z!-Union{Tuple{LH}, Tuple{Any, Any, Any, Any, Any, Val{LH}}} where LH","page":"Reference","title":"FastMultipole.rotate_z!","text":"Performs a z-axis rotation of the supplied solid harmonic coefficients. Computes e^{imϕ} as well.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.rotate_z_n!-Union{Tuple{LH}, Tuple{Any, Any, Any, Any, Any, Any, Any, Val{LH}, Any}} where LH","page":"Reference","title":"FastMultipole.rotate_z_n!","text":"Performs a z-axis rotation of the supplied solid harmonic coefficients. Computes e^{imϕ} as well.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.rotate_z_n_power!-Union{Tuple{LH}, Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Val{LH}, Any}} where LH","page":"Reference","title":"FastMultipole.rotate_z_n_power!","text":"Performs a z-axis rotation of the supplied solid harmonic coefficients. Computes e^{imϕ} and the multipole power at n as well.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.self_influence_matrices-Union{Tuple{TF}, Tuple{Any, Any, Any, Tree{TF}, Any, Any}} where TF","page":"Reference","title":"FastMultipole.self_influence_matrices","text":"self_influence_matrices(target_buffers, source_buffers, source_systems, target_tree, source_tree, derivatives_switches)\n\nConstructs influence matrices for all leaves of the tree. (Assumes source tree and target trees are identical.)\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.set_gradient!-Tuple{Matrix, Any, Any}","page":"Reference","title":"FastMultipole.set_gradient!","text":"set_gradient!(target_buffer, i_body, gradient)\n\nAccumulates gradient to target_buffer.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.set_hessian!-Tuple{Matrix, Any, Any}","page":"Reference","title":"FastMultipole.set_hessian!","text":"set_hessian!(target_buffer, i_body, hessian)\n\nAccumulates hessian to target_buffer.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.set_scalar_potential!-Tuple{Matrix, Any, Any}","page":"Reference","title":"FastMultipole.set_scalar_potential!","text":"set_scalar_potential!(target_buffer, i_body, scalar_potential)\n\nAccumulates scalar_potential to target_buffer.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.shrink_branch!-Tuple{Any, Any, Any}","page":"Reference","title":"FastMultipole.shrink_branch!","text":"Computes the smallest bounding box to completely bound all child boxes.\n\nShrunk radii are merely the distance from the center to the corner of the box.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.source_system_to_buffer!-NTuple{4, Any}","page":"Reference","title":"FastMultipole.source_system_to_buffer!","text":"source_system_to_buffer!(buffer::Matrix, i_buffer, system::{UserDefinedSystem}, i_body)\n\nCompatibility function used to sort source systems. It should be overloaded for each system (where {UserDefinedSystem} is replaced with the type of the user-defined system) to be used as a source and should behave as follows. For the i_bodyth body contained inside of system,\n\nbuffer[1:3, i_buffer] should be set to the x, y, and z coordinates of the body position used for sorting into the octree\nbuffer[4, i_buffer] should be set to the radius beyond which a multipole expansion is allowed to be evaluated (e.g. for panels, or other bodies of finite area/volume)\nbuffer[5:4+strength_dims, i_buffer] should be set to the body strength, which is a vector of length strength_dims\n\nAny additional information required for either forming multipole expansions or computing direct interactions should be stored in the rest of the column.\n\nIf a body contains vertices that are required for, e.g. computing multipole coefficients of dipole panels, these must be stored immediately following the body strength, and should be listed in a counter-clockwise order. For example, if I am using vortex tri-panels with strength_dims=3, I would set buffer[8:10,i] .= v1, buffer[11:13,i] .= v2, and bufer[14:16,i] .= v3, where v1, v2, and v3 are listed according to the right-hand-rule with thumb aligned with the panel normal vector.\n\nNote that any system acting only as a target need not overload source_system_to_buffer!.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.source_to_dipole!-NTuple{7, Any}","page":"Reference","title":"FastMultipole.source_to_dipole!","text":"assumes source expansion coefficients have already been calculated\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.source_to_vortex_point!-NTuple{7, Any}","page":"Reference","title":"FastMultipole.source_to_vortex_point!","text":"might be slightly faster than mirroredsourceto_vortex\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.strength_dims-Tuple{Any}","page":"Reference","title":"FastMultipole.strength_dims","text":"strength_dims(system::{UserDefinedSystem})\n\nReturns the cardinality of the vector used to define the strength of each body inside system. E.g., a point mass would return 1, and a point dipole would return 3. Should be overloaded for each user-defined system object (where {UserDefinedSystem} is replaced with the type of the user-defined system).\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.strength_to_value-Tuple{Any, Any}","page":"Reference","title":"FastMultipole.strength_to_value","text":"strength_to_value(strength, source_system)\n\nNOTE: this function is primarily used for the boundary element solver, and is not required for the FMM.\n\nConverts the strength of a body in source_system to a scalar value. Should be overloaded for each user-defined system object used with the boundary element solver.\n\nArguments:\n\nstrength::SVector{dim, Float64}: the strength of the body, where dim is the number of components in the strength vector (e.g., 1 for a point source, 3 for a point vortex, etc.)\nsource_system::{UserDefinedSystem}: the user-defined system object, used solely for dispatch\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.target_influence_to_buffer!-NTuple{5, Any}","page":"Reference","title":"FastMultipole.target_influence_to_buffer!","text":"target_influence_to_buffer!(target_buffer, i_buffer, ::DerivativesSwitch{PS,GS,HS}, target_system::{UserDefinedSystem}, i_target) where {PS,GS,HS}\n\nNOTE: this function is primarily used for the boundary element solver, and is not required for the FMM.\n\nUpdates the target_buffer with influences from target_system for the i_targetth body. Should be overloaded for each user-defined system object (where {UserDefinedSystem} is replaced with the type of the user-defined system) to be used as a target, assuming the target buffer positions have already been set. It should behave as follows:\n\ntarget_buffer[4, i_buffer] should be set to the scalar potential at the body position\ntarget_buffer[5:7, i_buffer] should be set to the vector field at the body position\ntarget_buffer[8:16, i_buffer] should be set to the vector gradient at the body position\n\nThe following convenience functions can may be used to access the buffer:\n\nset_scalar_potential!(target_buffer, i_buffer, scalar_potential): accumulates the scalar_potential to the i_buffer body in target_buffer\nset_gradient!(target_buffer, i_buffer, gradient): accumulates gradient to the i_buffer body in target_buffer\nset_hessian!(target_buffer, i_buffer, hessian): accumulates hessian to the i_buffer body in target_buffer\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.translate_local_z!-Union{Tuple{LH}, Tuple{Any, Any, Any, Any, Val{LH}}} where LH","page":"Reference","title":"FastMultipole.translate_local_z!","text":"Overwrites translated_weights\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.translate_multipole_to_local_z!-Union{Tuple{LH}, Tuple{Any, Any, Any, Any, Val{LH}}} where LH","page":"Reference","title":"FastMultipole.translate_multipole_to_local_z!","text":"Overwrites translated_weights\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.translate_multipole_to_local_z_m01_n-Union{Tuple{LH}, Tuple{Any, Any, Any, Val{LH}, Any, Any}} where LH","page":"Reference","title":"FastMultipole.translate_multipole_to_local_z_m01_n","text":"This function should receive n!tnp1 = 1/t when n=0\n\nCalculates ϕn0, ϕn1, χn1 for P=n\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.translate_multipole_to_local_z_n!-Union{Tuple{LH}, Tuple{Any, Any, Any, Any, Any, Val{LH}}} where LH","page":"Reference","title":"FastMultipole.translate_multipole_to_local_z_n!","text":"Overwrites translated_weights\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.translate_multipole_z!-Union{Tuple{LH}, Tuple{Any, Any, Any, Any, Val{LH}}} where LH","page":"Reference","title":"FastMultipole.translate_multipole_z!","text":"Overwrites translated_weights\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.tune_fmm-Tuple{Tuple, Tuple}","page":"Reference","title":"FastMultipole.tune_fmm","text":"tune_fmm(target_systems, source_systems; optargs...)\n\nTune the Fast Multipole Method (FMM) parameters for optimal performance on the given target and source systems, optionally subject to an error tolerance.\n\nArguments\n\ntarget_systems::Union{Tuple,{UserDefinedSystem}}: a user-defined system object (or a tuple of them) for which the FMM interface functions have been defined\nsource_systems::Union{Tuple,{UserDefinedSystem}}: a user-defined system object (or a tuple of them) for which the FMM interface functions have been defined\n\nKeyword Arguments\n\nε_tol::Union{Nothing,Float64}: the error tolerance for the FMM; if nothing, the FMM will simply use the expansion_order keyword argument to fix the expansion order\nexpansion_order::Int: the max expansion order for the FMM; defaults to 4\nleaf_size_source::Int: the leaf size for the source systems; defaults to default_leaf_size(source_systems)\nmax_expansion_order::Int: the maximum allowable expansion order if an error tolerance is requested; defaults to 20\nmultipole_acceptances::AbstractRange{Float64}: a range of multipole acceptance critia to test; defaults to range(0.3, stop=0.8, step=0.1)\nlamb_helmholtz::Bool: whether to use the Lamb-Hellmholtz decomposition; defaults to false\nverbose::Bool: whether to print progress information; defaults to true\nkwargs...: additional keyword arguments to pass to the fmm! function\n\nReturns\n\ntuned_params::NamedTuple: a named tuple containing the best parameters found during tuning, which can be used in subsequent fmm! calls by splatting it as a keyword argument:`:\nleaf_size_source::Int: the optimal leaf size for the source systems\nexpansion_order::Int: the optimal expansion order for the FMM\nmultipole_acceptance::Float64: the optimal multipole acceptance criterion\ncache::Tuple: a tuple containing the cache used during tuning, which can be reused for subsequent fmm! calls by splatting it as a keyword argument\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.update_Ts_0!-Union{Tuple{TF}, Tuple{Any, Any, TF, Any}} where TF","page":"Reference","title":"FastMultipole.update_Ts_0!","text":"Returns sβ, cβ, and 1n appropriate for calling updateTsn! for n=1\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.update_eimϕs_0!-Tuple{Any, Any}","page":"Reference","title":"FastMultipole.update_eimϕs_0!","text":"Returns eiϕreal, eiϕimag, eimϕreal, and eimϕimag appropriate for inputs for n=1 in updateeimϕsn!\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.update_eimϕs_n!-NTuple{6, Any}","page":"Reference","title":"FastMultipole.update_eimϕs_n!","text":"Returns eimϕreal and eimϕimag for n\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.update_nonself_influence!-Tuple{Any, Vector, FastMultipole.Matrices, Vector, Tree, Tree, Vector{UnitRange{Int64}}, Vector{UnitRange{Int64}}, Vector{StaticArraysCore.SVector{2, Int32}}, Vector{UnitRange{Int64}}}","page":"Reference","title":"FastMultipole.update_nonself_influence!","text":"update_nonself_influence!(right_hand_side, nonself_matrices::Matrices, old_influence_storage::Vector, source_tree::Tree, target_tree::Tree, strengths_by_leaf::Vector{UnitRange{Int}}, index_map::Vector{UnitRange{Int}}, direct_list::Vector{SVector{2,Int32}}, targets_by_branch::Vector{UnitRange{Int}})\n\nUpdates the right-hand side vector based on the non-self influence matrices and the current strengths of the source systems. Does this by removing the old influence and adding the new.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.value_to_strength!-NTuple{4, Any}","page":"Reference","title":"FastMultipole.value_to_strength!","text":"value_to_strength!(source_buffer, source_system, i_body, value)\n\nNOTE: this function is primarily used for the boundary element solver, and is not required for the FMM.\n\nConverts a scalar value to a vector strength of a body in source_system. Should be overloaded for each user-defined system object used with the boundary element solver.\n\nArguments:\n\nsource_buffer::Matrix{Float64}: the source buffer containing the body information\nsource_system::{UserDefinedSystem}: the user-defined system object, used solely for dispatch\ni_body::Int: the index of the body in source_buffer to set the strength for\nvalue::Float64: the scalar value used to set the strength\n\nThe following convenience function may be helpful when accessing the buffer:\n\nget_strength(source_buffer, source_system, i_body): returns the strength of the i_body body in source_buffer, formatted as a vector (e.g. strength::SVector{dim,Float64})\n\n\n\n\n\n","category":"method"},{"location":"#FastMultipole","page":"Introduction","title":"FastMultipole","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A fast, multi-system, multi-kernel, differentiable implementation of the fast multipole method for use with scalar-plus-vector potential N-body problems in pure Julia.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Author: Ryan Anderson","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Features:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"solves N-body problems governed by the Laplace (1r) kernel, with work planned to support the Helmholtz kernel in the future\nincorporates seamlessly into existing Julia code without modifications (just the addition of a few interface functions)\noffers convenience functions for determining the expansion coefficients for source, dipole, and vortex points, filaments, and panels (this list is growing!)\nprovides velocity and velocity gradient (or their equivalent for non-fluids problems) obtained using analytic expressions (no finite difference)\nuses O(p^3) translation operators (where p is the expansion order)\nautomated CPU-parallelization of expansions and direct interactions\nsupports GPU-parallelization of direct interactions with user-defined kernels\nForwardDiff and ReverseDiff compatible","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Installation:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add https://github.com/byuflowlab/FastMultipole.git","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Documentation:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"learn basic useage in the Quick Start tutorial\ndiscover more features in the Guided Examples\nfine-tune performance in the Advanced Usage section (for FMM experts)\nsee the full API","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<!– * brush up on the Theory –>","category":"page"}]
}
